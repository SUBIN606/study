> 처음부터 자는 개발자가 플랫폼을 저수준에서 다 알 필요가 없도록 설계됐다. 하지만 성능에 관심있는 개발자라면 기본적인 JVM 기술 스택의 구조를 이해해야 한다.

# JVM

JVM(Java Virtual Machine)은 하드웨어 및 운영 체제 독립성을 지원한다.
JVM에 의해 실행될 컴파일된 코드는 하드웨어 및 운영 체제에 독립적인 바이너리 형식을 사용하여 표현되며 일반적으로 `class`파일 형식을 사용한다.

JVM은 스택 기반의 해석 머신이다. 레지스터는 없지만 일부 결과를 실행 스택에 보관하며, 이 스택의 맨 위에 쌓인 값(들)을 가져와 계산한다.

JVM 인터프리터(해석기)의 기본 로직은, 평가 스택을 이용해 중간값들을 담아두고 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구성하는 옵코드(opcode)를 하나씩 순서대로 처리하는 'while 루프 안의 switch문'이다.

## JIT 컴파일
자바 프로그램은 바이트코드 인터프리티가 가상화한 스택 머신에서 명령어를 실행하며 시작된다. CPU를 추상화한 구조라서 다른 플랫폼에서도 클래스 파일을 문제없이 실행할 수 있지만, 프로그램이 성능을 최대로 내려면 네이티브 기능을 활요해 CPU에서 직접 프로그램을 실행시켜야 한다.

JIT(Just-in-Time) 컴파일이란 프로그램 단위(메서드와 루프)를 인터프리티드 바이트코드에서 네이티브 코드로 컴파일하는 것이다. 

핫스팟은 인터프리티드 모드로 실행하는 동안 애플리케이션을 모니터링하면서 가장 자주 실행되는 코드 파트를 발견해 JIT 컴파일을 수행한다.

<img src="../assets/jvm.png"/>

## Run-Time Data Areas

JVM은 프로그램 실행 중에 사용되는 다양한 런타임 데이터 영역을 정의한다. 런타임 데이터 영역 중 일부는 JVM이 실행될 때 만들어져서 JVM이 종료될때 파괴되고, 나머지는 쓰레드별로 생성되기 때문에 쓰레드가 소멸될때 함께 파괴된다.

### pc Register

JVM은 한 번에 많은 스레드를 실행할 수 있으며, 각 JVM 스레드에는 자체 `프로그램 카운터 레지스터(Program Counter Resiter)`가 있다. JVM 스레드는 해당 스레드에 대한 현재 메소드를 실행한다.

### Java Virtual Machine Statcks

각 JVM 스레드에는 스레드와 동시에 생성된 개인 `JVM 스택`이 있다. JVM 스택은 프레임을 저장하며 로컬 변수와 부분적 결과를 저장하고 메소드 호출 및 반환 역할을 한다.
JVM 스택은 프레임을 푸시하고 팝하는 것 외에는 조작되지 않으므로 프레임이 힙에 할당될 수 있다.

### Heap

JVM에는 모든 JVM 스레드 간에 공유되는 `힙(Heap)`이 있다. 힙은 모든 클래스 인스턴스 및 배열에 대한 메모리가 할당되는 런타임 데이터 영역이다.

힙은 JVM 시작 시 생성되며, 객체에 대한 힙 스토리지는 가비지 컬렉터에 의해 회수된다.

### Method Area

`메소드 영역(Method Area)`은 JVM의 모든 스레드 간에 공유된다.
메소드 영역 역시 JVM 시작 시 생성되며, 논리적으로는 힙의 일부이다.

## JVM 메모리 관리
자바는 가비지 수집(Garbage Colletion)이라는 프로세스를 이용해 힙 메모리를 자동으로 관리한다. 가비지 수집이란 한 마디로 JVM이 더 많은 메모리를 할당해야 할 때 불필요한 메모리를 회수하거나 재사용하는 불확정적 프로세스다.

일단 GC가 실행되면 그동안 다른 애플리케이션은 모두 중단(stop-the-world)되고 하던 일은 멈춰야 한다.

GC가 실행되면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈추고, GC 작업을 완료한 이후에야 중단됐던 작업을 다시 시작한다.

# GC
자바 가비지 수집의 요체는, 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하며 쓸모없는 객체를 알아서 제거하는 것이다. 이렇게 자동 회수한 메모리는 깨끗이 비우고 재활용할 수 있다.

1. 힙(heap) 내의 객체 중에서 가비지를 찾아낸다.
3. 찾아낸 가비지를 처리해서 힙의 메모리를 회수한다.

자바 CG는 객체가 가비지인지 판별하기 위해 `reachability`라는 개념을 사용한다. 어떤 객체에 유효한 참조가 있으면 `reachable`, 없으면 `unreachable`로 구별하고, `unreachable` 객체를 가비지로 간주해 GC를 수행한다.

한 객체는 여러 다른 객체를 참조하고, 참조된 다른 객체들도 마찬가지로 또 다른 객체들을 참조할 수 있으므로 객체들은 참조 사슬을 이룬다. 이런 상황에서 유효한 참조 여부를 파악하려면 항상 유효한 최초의 참조가 있어야 하는데 이를 객체 참조의 root set이라고 한다.

root set으로부터 어떤 식으로든 참조 관계가 있다면 reachable 객체라고 판단하고, 없다면 unreachable 객체로 판단한다.


## 마크 앤 스위프
root set에서 시작하는 참조의 관계를 추적하는 방식이다.

`Mark Phase`와 `Sweep Phase`로 나뉘게 된다. Mark Phase에서는 가비지 대상이 아닌 객체에 마킹하는 방식으로 수행되고, Mark Phase가 끝나면 곧바로 Sweep Phase로 진입한다. 이 단계에서는 마킹 정보를 활용해 마킹되지 않은 객체를 지우는 작업을 한다. 그리고 Sweep이 완료되고 살아남은 모든 객체의 마킹 정보를 초기화한다.

1. 할당 리스트를 순회하면서 마크 비트를 지운다.
2. GC 루트부터 살아 있는 객체를 찾는다.
3. 이렇게 찾은 객체마다 마크 비트를 세팅한다.
4. 할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾는다.
5. 힙에서 메모리를 회수해 프리 리스트에 되돌린다.
6. 할당 리스트에서 객체를 삭제한다.
> 할당 리스트란 할당됐지만, 아직 회수되지 않은 객체를 가리키는 포인터를 포함한다.

## 약한 세대별 가설(Weak Generational Hypothesis)
약한 세대별 가설은 JVM 메모리 관리의 이론적 근간을 형성한다. 

> JVM 및 유사 소프트웨어 시스템에서 객체 수명은 이원적 분포 양상을 보인다. 거의 대부분의 객체는 아주 짧은 시간만 살아있지만, 나머지 객체는 기대 수명이 훨씬 길다.

결론은 '가비지를 수집하는 힙은, 단명 객체를 쉽고 빠르게 수집할 수 있게 설계해야 하며, 장수 객체와 단명 객체를 완전히 떼어놓는 게 가장좋다'는 거다.

핫스팟은 몇 가지 메커니즘을 응용하여 약한 세대별 가설을 십분 활용한다.

- 객체마다 세대 카운드(generational count, 객체가 지금까지 무사 통과한 가비지 수집 횟수)를 센다.
- 큰 객체를 제외한 나머지 객체는 에덴(Eden) 공간에 생성한다. 여기서 살아남은 객체는 다른 곳으로 옮긴다.
- 장수했다고 할 정도로 충분히 오래 살아남은 객체들은 별도의 메모리 영역(올드 또는 테뉴어드 세대)에 보관한다.

세대별 수집 목적에 따라 메모리를 상이한 영역으로 나누면 핫스팟의 마크 앤 스위프 수집의 구현에 따라서 그 결과가 더 세분화된다. 여기서 중요한 건, 외부에서 영(young)세대 내부를 가리키는 포인터를 계속 추적하는 기법이다. 덕분에 GC 사이클에서 살아남은 젊은 객체들을 집어내느라 전체 객체 그래프를 다 뒤질 필요가 없다.

## 핫스팟의 가비지 수집
자바는 OS를 이용해 동적으로 메모리를 관리하지 않는다. 대신 일단 프로세스가 시작되면 JVM은 메모리를 할당(또는 예약)하고 유저 공간에서 연속된 단일 메모리 풀을 관리한다.

이 메모리 풀은 각자의 목적에 따라 서로 다른 영역으로 구성되며, 객체는 보통 에덴 영역에 생성된다.

에덴은 대부분의 객체가 탄생하는 장소로, 단명 객체는 다른 곳에는 위치할 수 없으므로 특별히 잘 관리해야 하는 영역이다. 따라서 JVM을 여러 버퍼로 나누어 각 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활용하도록 배포한다. 이 구역을 스레드 로컬 할당 버퍼(TLAB, Thread-Local Allocation Buffer)라고 한다.

---
참고
- 자바 최적화
- [[JVM] Garbage Collection Algorithms](https://medium.com/@joongwon/jvm-garbage-collection-algorithms-3869b7b0aa6f)
- [Java Reference와 GC](https://d2.naver.com/helloworld/329631)
- [Java Garbage Collection](https://d2.naver.com/helloworld/1329)
