# 1장. 오브젝트와 의존관계

스프링은 자바를 기반으로 한 기술으로 객체지향 프로그래밍이 가능한 언어라는 것에 가장 큰 초점을 두었다. Java EE 기술의 혼란속에서 잃었던 객체지향 기술의 가치를 회복하고 객체지향 프로그래밍의 혜택을 누릴 수 있게 기본으로 돌아가고자 하는 것이 스프링의 핵심 철학이다.

그래서 스프링을 이해하려면 오브젝트에 깊은 관심을 가져야 한다. 애플리케이션에서 객체의 생성, 관계, 사용, 소멸까지의 전 과정을 진지하게 생각해볼 필요가 있다.

스프링은 오브젝트를 효과적으로 설계하고 구현하고, 사용하고, 이를 개선해 나갈 것인가를 자연스럽게 프레임 워크 형태로 제공한다.

## 1.1 초난감 DAO

> DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

`JDBC`를 이용해 User DAO클래스를 만든다고 가정할 때, 순서는 다음과 같다.

1. DB 연결을 위한 `Connection`을 가져온다.
2. SQL을 담은 `Statement(or PreparedStatement)`를 만든다.
3. 만들어진 `Statement`를 실행한다.
4. 조회의 경우 SQL 쿼리의 실행 결과를 `ResultSet`으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
5. 작업 중에 생성된 `Connection`, `Statement`, `ResultSet` 같은 리소스는 작업을 마친 후 반드시 닫아준다.
6. JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 `throws`를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다.

```java
public class UserDao {

  // 회원 추가
  // throws를 이용해 예외가 발생하면 메소드 밖으로 던진다
  public void add(User user) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");

    //1. DB 연결을 위한 Connection
    Connection c = DriverManager.getConnection(
      "jdbc:mysql://localhost/springbook", "spring", "book");

    //2. SQL을 담은 Statement 생성
    PreparedStatement ps = c.prepareStatement(
      "insert into users(id, name, password) values(?, ?, ?)");
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    //3. 만들어진 Statement 실행
    ps.executeUpdate();

    //4. 리소스 닫기
    ps.close();
    c.close();
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");

    //1. DB 연결을 위한 Connection
    Connection c = DriverManager.getConnection(
      "jdbc:mysql://localhost/springbook", "spring", "book");

    //2. SQL을 담은 Statement 생성
    PreparedStatement ps = c.prepareStatement(
      "select * from users where id = ?");
    ps.setString(1, id);

    //3. 만들어진 Statement 실행
    ResultSet rs = ps.executeUpdate();

    //4. ResultSet으로 받은 SQL 실행 결과를 정보를 저장할 오브젝트로 옮기기
    User user = new User();
    user.setId(rs.getString("id"));
    user.setName(rs.getString("name"));
    user.setPassword(rs.getString("password"));

    //5. 리소스 닫기
    rs.close();
    ps.close();
    c.close();

    return user;
  }

}
```

지금부터 지금 만든 이 초난감 DAO 코드를 객체지향 기술의 원리에 충실한 `스프링 스타일 코드`로 개선해 나갈 것이다.

일단 UserDao 클래스 코드의 문제점이 무엇일지 스스로 생각해보라. 왜 이 코드에 문제가 많은지, 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유가 뭔지, 개선했을 때의 장점은 무엇인지, 객체지향 설계의 원칙과는 무슨 상관이 있는지...

스프링을 공부한다는 건 이런 문제 제기와 의문에 대한 답을 찾아나가는 과정이다.

## 1.2 DAO의 분리

객체지향의 세계에서는 모든 것이 변한다. 오브젝트에 대한 셜계와 이를 구현한 코드가 변한다는 뜻이다. 소프트웨어 개발에서 끝이란 개념은 없다. 사용자의 비즈니스 프로세스와 그에 따른 요구사항이 끈임 없이 바뀌고 발전하기 때문이다. 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변화한다.

개발자가 객체를 설계할 때 미래의 변화를 가장 염두에 둬야 한다. 미래를 위해 설계하고 개발해야 한다.

**변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 해야 한다. 그리고 이것은 `분리와 확장`을 고려한 설계로 해낼 수 있다.**

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다. 문제는, 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 점이다.

변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다. 즉 **관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.**

`관심사의 분리(Separation of Concerns)`를 통해 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것이라 생각할 수 있다.

### DB 연결을 위한 Connection 오브젝트를 가져오는 부분을 분리하자

DB 커넥션을 가져오는 코드는 다른 관심사와 섞여 같은 `add()`메소드에 담겨있으며, `get()`메서드에도 중복되어 있다. 메소드를 만들수록 중복은 더 많아질 것이다.

### 중복 코드를 메소드로 추출한다.

중복된 DB 연결 코드를 `getConnection()`이라는 독립적인 메소드를 만들고, 각 메소드에서 호출해서 커넥션을 가져오게 만든다.

```java
private Connection getConnection() throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection(
      "jdbc:mysql://localhost/springbook", "spring", "book");

    return c;
}
```

앞으로는 DB연결과 관련된 변경이 있을 때 `getConnection()`메소드의 코드만 수정하면 된다. 변경이 다른 메소드에 영향을 주지 않고, 수정도 간단해진다.

이 작업은 UserDao의 기능에는 아무런 변화를 주지 않았다. 하지만 여러 메소드에 중복돼서 등장하는 특정 관심사항이 담긴 코드를 별도의 메소드로 분리해냈다. 이 작업은 기능에는 영향을 주지 않으면서 코드의 구조만 변경한다. 이런 작업을 `리팩토링`이라고 하며, 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것을 `메소드 추출`기법이라고 부른다.

### 상속을 통한 확장

슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 `protected`메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 `템플릿 메소드 패턴`이라고 한다.

서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 `팩토리 메소드 패턴`이라고 부르기도 한다.

템플릿 메소드 패턴 또는 팩토리 메소드 패턴으로 관심사항이 다른 코드를 분리해내고 서로 독립적으로 변경 또는 확장할 수 있도록 만드는 것은 간단하면서도 매우 효과적인 방법이다. 하지만 이 방법은 상속을 사용했다는 단점이 있다.

상속은 많은 한계점이 있다. 자바는 클래스의 다중 상속을 허용하지 않기 때문에 단지 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 상속을 적용하기 힘들다.
또다른 문제는 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다는 점이다. 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있기 때문에 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 수정하거나 다시 개발해야 할 수도 있으며, 이러한 이유 때문에 슈퍼클래스를 더이상 변경하지 않도록 제약을 가해야 할지도 모른다.

## 1.3 DAO의 확장

모든 오브젝트는 변한다. 그런데 오브젝트가 모두 동일한 방식으로 변하는 건 아니다. 관심사에 따라 분리한 오브젝트들은 제각기 독특한 변화의 특징을 가지며 다른 성격을 가진다. 변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다.

### 클래스의 분리

관심사가 다르고 변화의 성격이 다른 두 개의 관심사를 본격적으로 독립시키면서 동시에 손쉽게 확장할 수 있는 방법이 있다.
독립적인 클래스로 분리하는 방법이다. 클래스 내부에 인스턴스를 생성하고 저장하는 전역 변수를 두고 계속해서 사용하는 방법이 있다.

하지만 코드가 특정 클래스에 종속되어 상속을 사용했을 때 처럼 코드 수정 없이 기능을 변경할 수 없다.
특정 클래스와 그 코드에 종속적이게 되어버리면 자유롭게 확장하기가 힘들다.

### 인터페이스의 도입

두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어 줄 수 있다.

자바에서 추상화를 위해 제공하는 가장 유용한 도구는 인터페이스다.
인터페이스를 사용하면 자신을 구현한 클래스의 구체적인 정보는 감추고 인터페이스로 추상화한 최소한의 통로를 통해 접근할 수 있다. 접근하는 쪽에서는 사용할 클래스가 무엇인지 몰라도 되며 구현 클래스가 변경되어도 신경쓸 필요가 없다.

인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이다. 구현 방법은 나타나 있지 않다. 구현 방법은 인터페이스를 구현할 클래스들이 결정할 일이다.

이 방법의 문제점은 초기에 구현 클래스를 호출해서 오브젝트를 생성해야 한다는 것이다. 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정해야 한다.

### 관계설정 책임의 분리

오브젝트와 오브젝트 사이의 관계를 설정한다.

오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다. 오브젝트 사이의 관계가 만들어지려면 일단 만들어진 오브젝트가 있어야 하는데, 직접 생성자를 호출해 직접 오브젝트를 만드는 방법도 잇지만 외부에서 만들어준 것을 가져오는 방법도 있다. 메소드 파라미터나 생성자 파라미터를 이용하면 된다.

파라미터 타입을 인터페이스로 선언해두면 파라미터로 해당 인터페이스를 구현한 어떤 클래스라도 넘겨줄 수 있다.

> UserDao 오브젝트가 DConnectionManager 오브젝트를 사용하게 하려면 두 클래스의 오브젝트 사이에 런타임 사용관계 또는 링크, 또는 의존관계라고 불리는 관계를 맺어주면 된다.

### 원칙과 패턴

- 개방 폐쇄 원칙(OCP: Open-Closed Principle)

클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

- 높은 응집도와 낮은 결합도

응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.

책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지해야 한다. 하나의 변경이 발생할 때 다른 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 말한다.

- 전략 패턴

자신의 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리 시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.
