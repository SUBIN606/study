> 트랜잭션 경계를 설정하는 방법은 코드에 의한 프로그램적인 방법과, AOP를 이용한 선언적인 방법으로 구분할 수 있다. 전자는 트랜잭션을 다루는 코드를 직접 만들고, 후자는 AOP를 이용해 기존 코드에 트랜잭션 경계설정 기능을 부여해준다.

## 선언적 트랜잭션
선언적 트랜잭션 기능을 이용하면 코드 내에서 직접 트랜잭션을 관리하고 트랜잭션 정보를 파라미터로 넘겨서 사용하지 않아도 된다. 선언적 트랜잭션의 가장 큰 장점은 트랜잭션 스크립트 방식의 코드를 탈피할 수 있다는 것이다.

트랜잭션 스크립트란 하나의 트랜잭션 안에서 동작해야 하는 코드를 한 군데 모아서 만드는 방식이다. 보통 트랜잭션마다 하나의 메소드로 구성된다. 트랜잭션 내의 일부 작업은 메소드를 분리해서 만들 수 있지만, 그래도 같은 트랜잭션 안에서 동작함을 보장하려면 `Connection`과 같은 트랜잭션 정보가 담긴 파라미터를 계속 물고 다녀야 한다. 또한 트랜잭션 스크립트 방식의 코드에는 중복이 자주 발생하며 비즈니스 로직과 데이터 액세스 로직이 한데 코드에 섞여 있는 문제도 있다.

선언적 트랜잭션 경계설정을 사용하면 트랜잭션이 시작되고 종료되는 지점은 별도의 설정을 통해 결정된다. 또 작은 단위로 분리되어 있는 데이터 액세스 로직과 비즈니스 로직 컴포넌트와 메소드를 조합해서 하나의 트랜잭션에서 동작하게 만드는 것도 간단하다. 선언적 트랜잭션이 제공하는 `트랜잭션 전파`기능 덕분이다. 의미있는 작은 단위로 만들어진 오브젝트와 메소드를 적절한 순서대로 조합해서 호출하기만 하면 코드의 중복 없이 다양한 트랜잭션 안에서 동작하는 코드를 만들 수 있다.

결국 코드의 중복을 제거하고 작은 단위의 컴포넌트로 쪼개서 개발한 후에 이를 조합해서 쓸 수 있다. 다양한 로직이 복잡하게 결합돼서 하나의 업무를 처리하는 엔터프라이즈 시스템의 요구조건을 가장 잘 충족시켜줄 기술이다.

# `@Transactional`
트랜잭션 AOP를 적용하는 방법 중 하나로, `@Transactional` 애노테이션을 이용해 트랜잭션을 선언할 수 있다. 

`@Transactional` 애노테이션은 트랜잭션이 적용될 타깃 인터페이스 선언부, 인터페이스 메서드, 클래스 선언부, 클래스 메서드에 붙일 수 있다. Spring에서는 클래스 혹은 클래스 메서드에 붙일 것을 권장한다. 인터페이스에서 사용할수는 있으나, 인터페이스 기반 프록시를 사용하는 경우에만 예상하는대로 작동하기 때문이다.

> 인터페이스에 붙은 `@Transactional` 선언은 인터페이스 내의 모든 메서드에 적용되며, 동시에 메서드 레벨에도 지정할 수 있다. 이때는 메서드 레벨이 우선된다. 또한 클래스의 `@Transactional`은 인터페이스보다 우선한다. 즉, 우선순위는 클래스의 메서드 > 클래스 > 인터페이스의 메서드 > 인터페이스 순이다.

> `@Transactional` 애노테이션은 `public` 메서드에만 사용할 수 있다. 만약 `protected` 혹은 `private`, `package-private` 메서드에 해당 애노테이션을 붙이면 에러가 발생하지는 않지만 트랜잭션 설정이 되지 않는다. 만약 `public` 메서드가 아닌 곳에 사용하고 싶다면 다른 설정이 필요하다.

## 트랜잭션 전파(propagation)
트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성이다. 트랜잭션 경계의 시작 지점에서 트랜잭션 전파 속성을 참조해서 해당 범위의 트랜잭션을 어떤 식으로 진행시킬지 결정할 수 있다.

트랜잭션 전파 속성은[`org.springframework.transaction.annotation.Propagation`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html)에 정의된 것을 사용한다.

- REQUIRED: 미리 시작된 트랜잭션이 있으면 참여, 없으면 새 트랜잭션을 만듦
- SUPPORTS: 미리 시작된 트랜잭션이 있으면 참여, 없으면 트랜잭션없이 진행
- MANDATORY: 이미 시작된 트랜잭션이 있으면 참여하나 없으면 예외를 발생시킴. 혼자서 독립적인 트랜잭션을 진행하면 안 될 때 사용
- REQUIRES_NEW: 항상 새로운 트랜잭션을 시작, 이미 진행중인 트랜잭션이 있으면 보류시킴
- NOT_SUPPORTED: 트랜잭션을 사용하지 않음. 이미 진행 중인 트랜잭션이 있으면 보류시킴
- NEVER: 트랜잭션을 사용하지 않도록 강제함. 이미 진행 중인 트랜잭션도 존재하면 안 됨. 예외 발생
- NESTED: 이미 진행 중인 트랜잭션이 있으면 중첩 트랜잭션을 시작함

### REQUIRED
기본 속성으로 모든 트랜잭션 매니저가 지원하며, 대개 이 속성이면 충분하다.

미리 시작된 트랜잭션이 있으면 참여하고, 없으면 새로 시작한다. 하나의 트랜잭션이 시작된 후에 다른 트랜잭션 경계가 설정된 메서드를 호출하면 자연스럽게 같은 트랜잭션으로 묶인다.

기본적으로 참여하는 트랜잭션은 외부 트랜잭션(미리 시작된 트랜잭션)의 특성에 결합한다. 

### REQUIRED_NEW
항상 새로운 트랜잭션을 시작한다. 이미 진행 중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다. 

외부 트랜잭션의 속성을 따르지 않기 때문에 자체 격리 수준, 시간 제한, 읽기 전용 설정을 따른다.

### NESTED
이미 진행 중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다. 즉, 트랜잭션 안에서 다시 트랜잭션을 만들게 된다. 독립적인 트랜잭션을 만드는 것이 아니므로 `REQUIRED_NEW`와 다르다.

중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않는다.

## 읽기 전용 트랜잭션(`readOnly=true`)
트랜잭션을 읽기 전용으로 설정할 수 있는 속성이다. 성능 최적화 혹은 특정 트랜잭션 작업 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용할 수 있다.

일부 트랜잭션 매니저의 경우 읽기 전용 속성을 무시하고 쓰기 작업을 허용할 수 있음에 주의해야 한다.

일반적으로 읽기 전용 트랜잭션이 시작된 이후 INSERT, UPDATE, DELETE 같은 쓰기 작업이 진행되면 예외가 발생한다.

JDBC의 `Connection.setReadOnly(true)`를 호출한다. 이는 단지 힌트일 뿐이며 실제 데이터베이스 자체를 read-only 트랜잭션으로 생성할지 여부는 JDBC 드라이버에 따라 달라지고, 행위도 데이터 계층 프레임워크의 구현여부에 따라 달라질 수 있다.

읽기 작업만 하더라도 트랜잭션을 걸어주는 것이 좋은데, 트랜잭션을 걸지 않으면 모든 SELECT 쿼리마다 commit을 하기 때문에 성능이 떨어지기 때문이다.

---
참고
- [Spring Framework Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative-annotations)
- [enum class Propagation](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html)
- [권남 위키 Spring Transaction](https://kwonnam.pe.kr/wiki/springframework/transaction)
