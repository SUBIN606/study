# 트랜잭션

## What - 트랜잭션이란?

트랜잭션이란 애플리케이션에서 몇 개의 읽기와 쓰기를 `하나의 논리적 단위`로 묶는 방법이다. 개념적으로 한 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행된다.

트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도 할 수 있다는 것이다.

트랜잭션의 범위는 커넥션을 기준으로 한다.

### ACID

> 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)

### 원자성

시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물 수 없다.

여러 작업이 하나의 원자적인 트랜잭션으로 묶여있는데 결함 때문에 완료(커밋)될 수 없다면 어보트(롤백)되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 작업을 무시하거나 취소해야 한다.

### 일관성

트랜잭션은 데이터베이스의 내부 일관성을 지켜야 한다. 각 트랜잭션은 일관성을 보장하도록 프로그램을 작성한다.

모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.

### 격리성

동시에 실행되는 트랜잭션은 서로 격리된다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다.

예를 들어, 한 트랜잭션이 여러 번 쓴다면 다른 트랜잭션은 그 내용을 전부 볼 수 있든지 아무것도 볼 수 없든지 둘 중 하나여야 하고 일부분만 볼 수 있어서는 안된다.

### 지속성

트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.

---

## Why - 트랜 잭션을 사용하는 이유?

트랜잭션은 전체가 성공(커밋)하거나 실패(어보트, 롤백)한다. 트랜잭션이 실패하면 애플리케이션에서 안전하게 재시도 할 수 있다. **트랜잭션을 사용하면 애플리케이션에서 오류 처리를 하기가 훨씬 단순해진다.** (원인이 무엇이든 간에) 어떤 연산은 성공하고 어떤 연산은 실패하는 경우처럼 부분적인 실패를 걱정할 필요가 없기 때문이다.

---

## How

## 동시성 문제

두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행될 수 있다.

동시성 문제(경쟁 조건)는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다.

여러 클라이언트가 같은 데이터에 접근하려고 할 때 동시성 문제가 발생한다.

### 트랜잭션 격리(Isolation)

트랜잭션을 서로 격리해서 다른 트랜잭션이 영향을 주지 못하게 한다.

| 격리 수준                           | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| ----------------------------------- | ---------- | ------------------- | ------------ |
| READ UNCOMMITED(커밋되지 않은 읽기) | O          | O                   | O            |
| READ COMMITTED(커밋된 읽기)         |            | O                   | O            |
| REPEATABLE READ(반복 가능한 읽기)   |            |                     | O            |
| SEARIALIZABLE(직렬화 가능)          |            |                     |              |

> 격리 수준이 낮은 순서대로 정렬.
> 가장 쉬운 방법은 직렬화이지만, 성능 저하 문제가 있다.

### READ UNCOMMITED(커밋되지 않은 읽기)

트랜잭션 간 최소한의 보호만 제공하는 격리 수준으로, 다른 트랜잭션에 의해 변경되었지만 아직 커밋되지 않은 데이터를 읽을 수 있다(dirty read).

일반적으로 이 격리 수준은 오직 읽기 쿼리에만 사용되곤 한다.

RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리수준이다.

### READ COMMITTED(커밋된 읽기)

성능을 위해 트랜잭션 간의 일부 보호를 완화하는 잠금 전략을 사용한다. **트랜잭션은 다른 트랜잭션의 커밋되지 않은 데이터를 볼 수 없다.**
트랜잭션에는 잘못된 데이터가 표시되지는 않지만 표시되는 데이터는 타이밍에 다라 달라질 수 있다(NON-REPEATABLE READ).
> 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋난다.

`UPDATE ... WHERE` 혹은 `DELETE ... WHERE`작업을 수행할 때 다른 트랜잭션이 기다려야 할 수도 있다.

`SELECT ... FOR UPDATE` 혹은 `LOCK IN SHARE MODE`를 통해 기다리지 않고 수행할 수 있다.

### REPEATABLE READ(반복 가능한 읽기)

> `MySQL InnoDB`의 기본 격리 수준이다.

쿼리된 행이 다른 트랜잭션에 의해 변경되는 것을 방지하므로 반복 불가능한 읽기는 차단하지만 팬텀읽기는 차단하지 못한다.
> InnoDB는 팬텀리드도 막아준다.

트랜잭션 내의 모든 쿼리가 동일한 스냅샷의 데이터를 사용한다.

InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경한다. 이러한 변경 방식을 MVCC(Multi Version Concurrency Control)라고 한다. REPEATABLE READ는 이 MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.

### SEARIALIZABLE(직렬화 가능)

트랜잭션이 완료될 때가지 다른 트랜잭션이 데이터를 삽입하거나 변경하는 것을 방지하기 위해 가장 보수적인 잠금 전략을 사용한다.
SQL 표준에서 지정한 기본 격리 수준이지만 실제로 이정도의 엄격함은 거의 필요하지 않다.

---

격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따른 다양한 문제가 발생한다.

### 커밋되지 않은 데이터 다루기

- dirty read: 커밋되지 않은 데이터 읽기
- dirty write: 커밋되지 않은 데이터 덮어쓰기

위의 문제를 해결하기 위해 `READ COMMITTED` 격리 수준을 사용한다.
커밋된 데이터만 읽기 위해 커밋된 값과 트랜잭션 진행 중인 값을 따로 보관하고, 커밋된 데이터만 덮어쓰기 위해 행 단위 잠금을 사용한다. 같은 데이터를 수정한 트랜잭션이 끝날 때까지 대기한다.

### 읽는 동안 데이터 변경 - 1

- read skew: 읽는 시점에 따라 데이터가 바뀜

위의 문제를 해결하기 위해 `REPEATABLE READ` 격리 수준을 사용한다. 트랜잭션 동안 같은 데이터를 읽게 되는데, `MVCC(Multi-Version Concurrency Control)`로 구현하곤 한다.

### 변경 유실

- lost update: 변경 데이터 유실

위의 문제는 원자적 연산 사용, 명시적인 잠금, CAS(Compare And Set)으로 해결한다.
**원자적(atomic) 연산은 DB가 지원하는 것으로,** 동시 수정 요청에 대해 DB가 순차 처리한다.

```sql
update article set readcnt = readcnt+1 where id = 1
```

명시적 잠금은 조회할 때 수정할 행을 미리 잠그는 것이다. `select ... for update` 구문이 대표적인 예시이다.

```sql
select * from wikipage where id = 1 for update
```

CAS는 수정할 때 값이 같은지 비교해서 같은 경우에만 변경하는 방식이다.

### 읽는 동안 데이터 변경 - 2

- 한 트랜잭션의 결과가 다른 트랜잭션의 쿼리 결과에 영향을 미치는 경우
- 같은 데이터를 쓰지는 않지만 실제로는 경쟁상태인 경우

위의 문제는 `SEARIALIZABLE` 격리 수준을 사용한다. 인덱스 잠금이나 조건 기반 잠금 등을 사용해서 구현한다.

---

# 트랜잭션 전파
트랜잭션 전파(transaction propagation)란 트랜잭션 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식을 말한다.
``` text
A 트랜잭션 시작
- 작업1
- B.method(); // B 호출
- 작업2
A 트랜잭션 종료

-------------------------

B 트랜잭션 시작
- 작업1
- 작업2
- 작업3
B 트랜잭션 종료
```
위에 적힌대로 A 트랜잭션 내에서 B 코드를 호출하면 
- B는 새로운 트랜잭션을 만들지 않고 A에서 이미 시작한 트랜잭션에 참여하는 경우
  - 만약 B 트랜잭션이 끝나고 A 트랜잭션의 작업2에서 예외가 잘생하면 A, B에서 진행한 모든 작업이 취소됨
- B를 독립적인 트랜잭션으로 만드는 경우
  - B의 트랜잭션 경계를 빠져나오는 순간 B의 트랜잭션은 독자적으로 커밋 혹은 롤백될 것이고, A 트랜잭션은 그에 영향을 받지 않고 진행됨. 만약 A의 작업2에서 예외가 발생해도 B에서 이미 종료된 트랜잭션의 결과에는 영향을 주지 않음

이렇게 B와 같이 독자적인 트랜잭션 경계를 가진 코드에 대해 이미 진행 중인 트랜잭션이 어떻게 영향을 미칠 수 있는가를 정의하는 것이 트랜잭션 전파 속성이다.


여러 메서드 호출이 한 트랜잭션에 묶이도록 하기 위해 필요하다.

스프링의 `@Transactional`을 사용하면 메서드 간에 커넥션 객체를 전달하지 않아도 여러 메서드 호출을 한 트랜잭션으로 묶어서 실행한다.

```java
@Transactional
public void crate() {
  if(dao.checkDuplicate(req.getEmail())) {
    throw new DupEmailException();
  }

  //...

  dao.insert(member);

}

public boolean checkDuplicate(String email) {
  return jdbcTemplate.queryForObject(...) > 0;
}

public void insert(Member m) {
  jdbcTemplate.update(...);
}
```
