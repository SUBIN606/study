# Stream API
스트림은 자바 8 API에 추가된 기능이다. 스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있다. 또한 스트림을 이용하면 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.

자바 8의 스트림 API의 특징은
- 선언형: 더 간결하고 가독성이 좋아짐
- 조립할 수 있음: 유연성이 좋아짐
- 병렬화: 성능이 좋아짐

가 있다.

스트림이란 '데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소'로 정의할 수 있다.

## 스트림과 컬렉션
컬렉션과 스틤 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다.

데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이다. 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조다. 즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다.

반면 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조다(스트림에 요소를 추가하거나 스트림에서 요소를 제거하 수 없다). 스트림은 게으르게 만들어지는 컬렉션과 같다. 즉, 사용자가 데이터를 요청할 때만 값을 계산한다.

스트림은 딱 한 번만 탐색할 수 있다. 즉, 탐색된 스트림의 요소는 소비된다. 반복자와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.

컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다. 이를 외부 반복이라고 한다. 반면 스트림 라이브러리는 내부 반복을 사용한다.
``` java
List<String> names = new ArrayList<>();
for(Dish dish: menu) {  // 메뉴 리스트를 명시적으로 순차 반복한다.
  names.add(dish.getName());  // 이름을 추출해서 리스트에 추가한다.
}
```
``` java
List<String> names = menu.stream()
                        .map(Dish::getName)
                        .collect(toList());
```
내부 반복을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다. 내부 반복뿐 아니라 자바 8에서 스트림을 제공하는 더 다양한 이유가 있다. 스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택한다. 반면 `for-each`를 이용하는 외부 반복에서는 병렬성을 스스로 관리해야 한다.

스트림은 내부 반복을 사용하므로 반복 과정을 우리가 신경쓰지 않아도 된다. 하지만 이와 같은 이점을 누리려면 (filter나 map 같이) 반복을 숨겨주는 연산 리스트가 미리 정의되어 있어야 한다.

## 스트림 연산
스트림의 연산은 두 그룹으로 구분할 수 있다. 연결할 수 있는 스트림 연산을 중간 연산이라고 하며, 스트림을 닫는 연산을 최종 연산이라고 한다.

`filter`나 `sorted` 같은 중간 연산은 다른 스트림을 반환한다. 따라서 여러 중간 연산을 연결해서 질의를 만들 수 있다. 중간 연산의 중요한 특징은 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 것, 즉 게으르다(lazy)는 것이다. 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한 번에 처리하기 때문이다.

최종 연산은 스트림 파이프라인에서 결과를 도출한다. 보통 최종 연산에 의해 List, Integer, void 등 스트림 이외의 결과가 반환된다.

### 쇼트서킷
`allMatch`, `noneMatch`, `findFirst`, `findAny` 등의 연산은 모든 스트림의 요소를 처리하지 않고도 결과를 반환할 수 있ㅎ다. 원하는 요소를 찾았으면 즉시 결과를 반환할 수 있다. 이처럼 전체 스트림을 처리하지 않았더라도 결과를 반환할 수 있는 상황을 쇼트 서킷이라 부른다.

### 병렬성(Parallelism)
병렬성(parallelism)을 얻으려면 두 가지 일을 동시에 할 수 있는 하드웨어가 필요하다. CPU 하나에 있는 여러 개의 코어일 수도 있고, 컴퓨터 한 대에 있는 여러 CPU이거나 아니면 네트워크로 연결된 여러 대의 컴퓨터일 수도 있다.

락으로 적절히 보호하지 않은 상태로 멀티스레드 환경에서 코드를 실행하면, 다른 스레드가 수정한 결과가 소실될 수도 있다.

Java는 포크/조인 프레임워크를 통해 병렬 처리를 쉽게 구현할 수 있다.

> 병렬성은 한 태스크를 여러 하위 태스크로 나눠서 CPU의 다른 코어 또는 다른 머신에서 이들 하위 태스크를 병렬로 실행한다. 반면 동시성은 조금씩 연관된 작업을 같은 CPU에서 동작하는 것 또는 애플리케이션의 생산성을 극대화할 수 있도록 코어를 바쁘게 유지하는 것이 목표다.

> 동시성은 단일 코어 머신에서 발생할 수 있는 프로그래밍 속성으로 실행이 서로 겹칠 수 있는 반면, 병렬성은 병렬 실행을 하드웨어 수준에서 지원한다.

## Fork/Join 프레임워크
자바 7은 더 쉽게 병렬화를 수행하면서 에러를 최소화할 수 있도록 포크/조인 프레임워크 기능을 제공한다.

하나의 작업을 여러 개의 작은 Task로 쪼개고, 이 Task를 fork하여 병렬로 처리하고, 수행된 결과를 병합하기 위해 join 단계를 실행한다.

포크/조인 프레임워크에서는 서브태스크를 스레드 풀(ForkJoinPool)의 작업자 스레드에 분산 할당하는 `ExecutorService` 인터페이스를 구현한다.

컬렉션을 사용하는 애플리케이션에서 병렬 처리를 구현하는 데 어려운 점은 컬렉션이 스레드로부터 안전하지 않다는 것이다.

## Parallel Stream
Java에서는 스트림을 직렬(serial) 혹은 병렬(parallel)로 실행할 수 있다. 병렬로 스트림을 실행하면, Java 런타임은 스트림을 여러 하위 스트림으로 분할한다. 그리고 처리한 결과를 합친다.

스트림을 만들 때 특별히 지정하지 않으면 항상 직렬 스트림이고, 병렬 스트림을 만들려면 `Collection.parallelStream` 혹은 `BaseStream.parallel`을 호출해야 한다. 병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다. 따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

`parallelStream()`을 이용하면 병렬로 데이터를 작업 후 그 결과를 재조합할 수 있다. 이 메서드를 호출하면 내부적으로 `Spliterator`를 써서 작업을 분할하고 공용 포크/조인 풀에서 연산을 수행한다.

**스트림의 소스가 ArrayList, HashMap, ConcurrentHashMap의 인스턴스이거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.** 이 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 일을 다수의 스레드에 분배하기에 좋기 때문이다. 또한 이 자료구조들의 공통점은 원소들을 순차적으로 실행할 때의 참조 지역성(locality of reference)이 뛰어나다는 것이다. 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있다는 뜻이다. 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 대부분의 시간을 멍하니 보내게 된다. 따라서 참조 지역성은 다량의 데이터를 처리하는 벌크 연산을 병렬화할 때 아주 중요한 요소로 작용한다. 

병렬화는 공짜가 아니다. 병렬화를 이용하려면 스트림을 재귀적으로 분할해야 하고, 각 서브스트림을 서로 다른 스레드의 리듀싱 연산으로 할당하고, 이들 결과를 하나의 값으로 합쳐야 한다. 멀티코어 간의 데이터 이동은 우리 생각보다 비싸다. 따라서 코어 간에 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 다른 코어에서 수행하는 것이 바람직하다.

스트림을 병렬화해서 코드 실행 속도를 빠르게 하고 싶으면 항상 병렬화를 올바르게 사용하고 있는지 확인해야 한다.

### 병렬 스트림 사용 시 주의할 점
- 순서가 보장되지 않음
- ORM과 함께 사용할 때 주의해야 함
- 컬렉션이 작을수록 직렬 연산이 더 유리하다
- 상태 공유에 따른 부작용에 주의해야 함

> `findFirst`는 스트림에서 첫 번째 요소를 찾는다. 하지만 병렬 실행에서는 첫 번째 요소를 찾기 어려우므로 요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 `findAny`를 사용하는 것이 좋다.

병렬 스트림은 내부적으로 `ForkJoinPool`을 사용한다. 기본적으로 `ForkJoinPool`은 프로세서 수, 즉 `Runtime.getRuntime().availableProcessors()`가 반환하는 값에 상응하는 스레드를 갖는다.

``` java
// System 변수로 지정하는 방법
// 전역 설정 코드이므로 이후의 모든 병렬 스트림 연산에 영향을 준다.
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", String.valueOf(numOfCores)));
```

``` bash
java -Djava.util.concurrent.ForkJoinPool.common.parallelism=7
```
> 현재는 하나의 병렬 스트림에 사용할 수 있는 특정한 값을 지정할 수 없다. 특별한 이유가 없다면 `ForkJoinPool`의 기본값을 그대로 사용하는 것이 좋다.


---
-모던 자바 인 액션
-[Parallel streams in Java](https://blogs.oracle.com/javamagazine/post/java-parallel-streams-performance-benchmark)
-[Java Tutorial: Parallelism](https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html)
