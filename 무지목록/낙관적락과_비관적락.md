# 낙관적 락
낙관적 락은 이름 그대로 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법이다.

데이터베이스가 제공하는 락 기능을 사용하는 것이 아니라 JPA가 제공하는 버전 관리 기능을 사용한다. 즉, **애플리케이션이 제공하는 락이다.**

낙관적 락은 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다는 특징이 있다. (커밋하는 시점에 충돌을 알 수 있다.)

## `@Version`
JPA가 제공하는 낙관적 락을 사용하려면 `@Version` 어노테이션을 사용해서 버전 관리 기능을 추가해야 한다. 엔티티에 버전 관리용 필드를 하나 추가하고 `@Version`을 붙이면 된다.

엔티티를 수정할 때 마다 버전이 하나씩 자동으로 증가한다. 그리고 엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외가 발생한다.(WHERE 문에서 VERSION 정보가 추가되어 수정할 대상이 없는 것으로 판단하기 때문)
``` sql
-- 버전 사용 엔티티 UPDATE SQL 예시
UPDATE BOARD
SET
  TITLE=?,
  VERSION=?
WHERE
  ID=?
  AND VERSION=? -- 버전을 사용하는 엔티티는 검색 조건에 엔티티의 버전 정보가 추가된다.
```

**버전 정보를 사용하면 최초 커밋만 인정하기가 적용된다.**

> 락 옵션 없이 `@Version`만 있어도 낙관적 락이 적용된다. 락 옵션을 사용하면 락을 더 세밀하게 제어할 수 있다.

# 비관적 락
비관적 락은 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법이다.

**비관적 락은 데이터베이스가 제공하는 락 기능을 사용하며,** 대표적으로 `select for update` 구문이 있다.

## 타임아웃
비관적 락을 사용하면 락을 획들할 때까지 트랜잭션이 대기하게 된다. 이 때 무한정 대기할 수 없으므로 타임아웃 시간을 줄 수 있다.

# JPA 락
JPA가 제공하는 락은 조회하면서 즉시 락을 걸 수도 있고, 필요할 때 락을 걸 수도 있다.
```java
// 조회하면서 즉시 락 걸기
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC);

// 필요할 때 락 걸기
Board board = em.find(Board.class, id);

em.lock(board, LockModeType.OPTIMISTIC);
```
## JPA 낙관적 락
### NONE
> 락 옵션을 적용하지 않아도 `@Version`이 적용된 필드가 엔티티에 있으면 낙관적 락이 적용된다.

- 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경(삭제)되지 않아야 할 때 사용한다. 조회 시점부터 수정 시점까지를 보장한다.
- 엔티티를 수정할 때 버전을 체크하면서 버전을 증가한다. 데이터베이스의 버전 값이 현재 버전이 아니면 예외가 발생한다.
- 두 번의 갱신 분실 문제를 예방한다.

### OPTIMISTIC
이 옵션을 추가하면 엔티티를 조회만 해도 버전을 체크한다. 즉, 한 번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경하지 않음을 보장한다.

- 조회 시점부터 트랜잭션이 끝날 때까지 조회한 엔티티가 변경되지 않음을 보장한다.
- 트랜잭션을 커밋할 때 버전 정보를 조회해서(SELECT) 현재 엔티티의 버전과 같은지 검증하고, 같지 않으면 예외를 던진다.
- DIRTY READ와 NON-REPEATABLE READ를 방지한다.

트랜잭션을 커밋할 때 데이터베이스에 있는 버전 정보를 SELECT 쿼리로 조회해서 처음에 조회한 엔티티의 버전 정보와 비교한다.

락 옵션을 걸지 않고 `@Version`만 사용하면 엔티티를 수정해야 버전 정보를 확인하지만 OPTIMISTIC 옵션을 사용하면 엔티티를 수정하지 않고 단순히 조회만 해도 버전을 확인한다.

### OPTIMISTIC_FORCE_INCREMENT
낙관적 락을 사용하면서 버전 정보를 강제로 증가한다.

- 논리적인 단위의 엔티티 묶음을 관리할 수 있다.
- **엔티티를 수정하지 않아도 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가시킨다.** 이 때 데이터베이스의 버전이 엔티티의 버전과 다르면 예외가 발생한다. 또한 추가로 엔티티를 수정하게 되면 수정 시 버전 UPDATE가 발생해서 총 두 번의 버전 증가가 나타날 수 있다.
- 강제로 버전을 증가해서 논리적인 단위의 엔티티 묶음을 버전 관리할 수 있다.

## JPA 비관적 락
JPA가 제공하는 비관적 락은 데이터베이스 트랜잭션 락 메커니즘에 의존하는 방법이다.

주로 SQL 쿼리에 `select for update` 구문을 사용하면서 시작하고 버전 정보는 사용하지 않는다.

비관적 락은 엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있으며, 데이터를 수정하는 즉시 트랜잭션 충돌을 감지할 수 있다는 특징이 있다.

### PESSIMISTIC_WRITE
비관적 락이라 하면 일반적으로 이 옵션을 뜻한다. 데이터베이스에 쓰기 락을 걸 때 사용한다.

- 데이터베이스에 쓰기 락을 건다.
- 데이터베이스 `select for update`를 사용해 락을 건다.
- NON-REPEATABLE READ를 방지한다. 락이 걸린 로우는 다른 트랜잭션이 수정할 수 없다.

### PESSIMISTIC_READ
데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용한다.

- MySQL: `lock in share mode`
- PostgreSQL: `for share`

### PESSIMISTIC_FORCE_INCREMENT
비관적 락중 유일하게 버전 정보를 사용한다. 비관적 락이지만 버전 정보를 강제로 증가시킨다. `nowait`을 지원하는 데이터베이스에 대해서 `for update nowait` 옵션을 적용한다.

- Oracle: `for update nowait`
- PostgreSQL: `for update nowait`
- `nowait`을 지원하지 않으면 `for update`가 사용된다.

---
참고
- 자바 ORM 표준 JPA 프로그래밍
