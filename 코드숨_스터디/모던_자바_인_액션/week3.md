# 3. 람다 표현식

동작 파라미터화를 이용하면 더 유연하고 재사용할 수 있는 코드를 만들 수 있다. 익명 클래스로 구현할 수 있지만 코드가 깔끔하지 않다. 깔끔하지 않은 코드는 실전에 적용하는 것을 막는 요소다. 더 깔끔한 코드로 동작을 구현하고 전달하는 람다 표현식이 있다.

## 람다란 무엇인가?
람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다.

- 익명: 보통의 메서드와 달리 이름이 없음
- 함수: 메서드처럼 특정 클래스에 종속되지 않아 '함수'라고 부른다
- 전달: 람다 표현식은 인수로 전달하거나 변수로 저장할 수 있다
- 간결성: 익명 클래스보다 깔끔한 코드로 구현 가능

람다를 이용하면 간결한 방식으로 코드를 전달할 수 있다. 람다가 기술적으로 자바 8 이전의 자바로 할 수 없었던 일을 제공하는 것은 아니다.

람다는 세 부분으로 이루어진다.
1. 파라미터
2. 화살표: 화살표(`->`)는 람다의 파라미터 리스트와 바디를 구분한다
3. 바디: 람다의 반환값에 해당하는 표현식으로 람다 표현식에는 `return`이 함축되어 있으므로 명시적으로 사용하지 않아도 된다

``` java
// 람다의 세 부분
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

// 표현식(expression) 스타일 람다
(parameters) -> expression

// 블록(구문) 스타일 람다
(parameters) -> { statments; }
```

## 람다는 어디에, 어떻게 사용할까?
함수형 인터페이스라는 문맥에서 람다 표현식을 사용할 수 있다.

### 함수형 인터페이스
함수형 인터페이스는 정확히 하나의 추상 메서드를 지정하는 인터페이스다. `Comprator`, `Runnable` 등이 있다.

> 많은 디폴트 메서드를 가지고 있더라도 추상 메서드가 오직 하나면 함수형 인터페이스다.

``` java
// 함수형 인터페이스 예시
public interface Adder {
  int add(int a, int b);
}
```

람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 전체 표현식을 함수형 인터페이스의 인스턴스로 취급(구현체)할 수 있다.

``` java
// 람다 사용
Runnable r1 = () -> System.out.println("Hello World 1");

// 익명클래스 사용
Runnable r2 = new Runnable() {
  public void run() {
    System.out.println("Hello World 2");
  }
}

public static voic prcess(Runnable r) {
  r.run();
}
process(r1);  // Hello World 1 출력
process(r2);  // Hello World 2 출력
process(() -> System.out.println("Hello World 3")); // Hello World 3 출력
```

### 함수 디스크립터
함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.

예를 들어 `Runnable` 인터페이스의 유일한 추상 메서드 `run()`은 인수와 반환값이 없으므로 `Runnable` 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있다.

> `@FunctionalInterface`는 함수형 인터페이스임을 가리키는 애노테이션으로, 해당 애노테이션을 선언했지만 실제로 함수형 인터페이스가 아니라면 컴파일러가 에러를 발생시킨다.

## 람다 활용: 실행 어라운드 패턴
자원 처리에 사용하는 순환 패턴은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이루어진다. 즉, 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 갖는다. 이와 같은 형식의 코드를 실행 어라운드 패턴이라고 부른다.

## 함수형 인터페이스 사용
함수형 인터페이스는 오직 하나의 추상 메서드를 지정한다. 함수형 인터페이스의 추상 메서드는 람다 표현식의 시그니처를 묘사한다. 함수형 인터페이스의 추상 메서드 시그니처를 함수 디스크립터라고 한다.


자바의 모든 형식은 참조형 아니면 기본형에 해당한다. 하지만 제네릭 파라미터에는 참조형만 사용할 수 있다. 제네릭의 내부 구현 때문에 어쩔 수 없는 일이다.

기본형을 참조형으로 변환하는 박싱, 참조형을 기본형으로 변환하는 언박싱을 제공하고, 오토박싱이라는 기능도 제공하지만 이러한 변환 과정은 비용이 소모된다. 박싱한 값은 메모리를 더 소비하며 기본형을 가져올 때도 메모리를 탐색하는 과정이 필요하다.

자바 8에서는 기본형을 입출력으로 사용하는 상황에서 오토박싱 동작을 피할 수 있도록 '기본형 특화' 함수형 인터페이스를 제공한다.

## 형식 검사, 형식 추론, 제약
### 형식 검사
람다가 사용되는 콘텍스트를 이용해서 람다의 형식을 추론할 수 있다. 어떤 콘텍트스에서 기대되는 람다 표현식의 형식을 대상 형식이라고 부른다.

대상 형식 이라는 특징 때문에 같은 람다 표현식이더라도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용될 수 있다.

### 형식 추론
자바 컴파일러는 람다 표현식이 사용된 콘텍스트(대상 형식)를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론한다. 즉, 대상 형식을 이용해서 함수 디스크립터를 알 수 있으므로 컴파일러는 람다의 시그니처도 추론할 수 있다.

상황에 따라 명시적으로 형식을 포함하는 것이 좋을 때도 있고 형식을 배제하는 것이 가독성을 향상시킬 때도 있다. 정해진 규칙은 없다.
``` java
// 형식추론 하지 않음
Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

// 형식 추론 함
Comparator<Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```

### 지역 변수 사용
람다 표현식에서는 익명 함수가 하는 것처럼 자유변수(파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수)를 활용할 수 있다. 이와 같은 동작을 랍다 캡쳐링 이라고 부른다.

``` java
int portNumber = 1337;

// portNumber 변수를 캡처
Runnable r = () -> System.out.println(portNumber);

portNumber = 31337; //컴파일에러
```

람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처(자신의 바디에서 참조할 수 있도록)할 수 있다. 하지만 그러려면 지역 변수는 명시적으로 final로 선언되어 있어야 하거나, 실질적으로 final로 선언된 변수와 똑같이 사용되어야 한다. 즉, 람다 표현식은 한 번만 할당할 수 있는 지역 변수를 캡처할 수 있다.

인스턴스 변수는 힙에 저장되는 반면, 지역 변수는 스택에 위치한다. 람다에서 지역 변수에 바로 접근할 수 있다는 가정하에 람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수 있다. 따라서 자바 구현에서는 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공한다. 따라서 복사본의 값이 바뀌지 않아야 하므로 지역 변수에는 한 번만 값을 할당해야 한다는 제약이 생긴 것이다.

> 클로저(Closure)란 함수의 비지역 변수를 자유롭게 참조할 수 있는 함수의 인스턴스를 가리킨다. 예를 들어 클로저를 다른 함수의 인수로 전달할 수 있다. 클로저는 클로저 외부에 정의된 변수의 값에 접근하고, 값을 바꿀 수 있다. 자바 8의 람다와 익명 클래스는 클로저와 비슷한 동작을 수행한다. 다만 람다와 익명 클래스는 람다가 정의된 메서드의 지역 변수의 값은 바꿀 수 없다.

## 메서드 참조
메서드 참조를 이용하면 기존의 메서드 정의를 재활용해서 람다처럼 전달할 수 있다. 때로는 람다 표현식보다 메서드 참조를 사용하는 것이 더 가독성이 좋으며 자연스러울 수 있다.

메서드 참조는 특정 메서드만을 호출하는 람다의 축약형이라고 생각할 수 있다. 메서드 참조를 이용하면 기존 메서드 구현으로 람다 표현식을 만들 수 있다. 이때 명시적으로 메서드명을 참조함으로써 가독성을 높일 수 있다.

메서드 참조는 메서드명 앞에 구분자(::)를 붙이는 방식으로 메서드 참조를 활용할 수 있다.

메서드 참조는 새로운 기능이 아니라 하나의 메서드를 참조하는 람다를 편리하게 표현할 수 있는 문법으로 간주할 수 있다.
``` java
//람다
(Apple apple) -> apple.getWeight();
//메서드참조단축표현
Apple::getWeight
```

1. 정적 메서드 참조: `Integer::parseInt`
2. 다양한 형식의 인스턴스 메서드 참조: `String::length`
3. 기존 객체의 인스턴스 메서드 참조: `expensiveTransaction::getValue`

### 생성자 참조
`ClassName::new`처럼 클래스명과 `new`키워드를 이용해서 기존 생성자의 참조를 만들 수 있다.

인스턴스화하지 않고도 생성자에 접근할 수 있는 기능을 다양한 상황에 응용할 수 있다.

## 람다 표현식을 조합할 수 있는 유용한 메서드
Comparator, Funtion, Predicate 같은 함수형 인터페이스는 람다 표현식을 조합할 수 있도록 유틸리티 메서드를 제공한다. 간단한 여러 개의 람다 표현식을 조합해서 복잡한 람다 표현식을 만들 수 있다는 것이다.

여러 유틸리티 메서드를 조합해서 다양한 변환 파이프라인을 만들 수 있다.

---
