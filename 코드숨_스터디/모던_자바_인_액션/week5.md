# 6. 스트림으로 데이터 수집
## 6.1 컬렉터란 무엇인가?
Collector 인터페이스 구현은 스트림의 요소를 어떤식으로 도출할지 지정한다.

`Collectors`에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.
- 스트림 요소를 하나의 값으로 리듀스 하고 요약
- 요소 그룹화
- 요소 분할

## 그룹화
데이터 집합을 하나 이상의 특성으로 분류해서 그룹화 하는 연산

자바 8의 함수형을 이용하면 가독성 있는 한 줄의 코드로 그룹화를 구현할 수 있다.

`Collectors.groupingBy`를 이용해서 쉽게 메뉴를 그룹화할 수 있다.

## 분할
분할은 분할 함수라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다.

분할 함수가 반환하는 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점이다.

## Collector 인터페이스
``` java
public interface Collector<T, A, R> {
  Supplier<A> supplier();
  BiComsumer<A, T> accumulator();
  Function<A, R> finisher();
  BinaryOperator<A> combiner();
  Set<Characteristics> chracteristics();
}
```
- T는 수집될 스트림 항목의 제네릭 형식
- A는 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식이다
- R은 수집 연산 결과 객체의 형식(항상 그런 것은 아니지만 대개 컬렉션 형식)이다

### supplier: 새로운 결과 컨테이너 만들기
`supplier`메서드는 빈 결과로 이루어진 `Supplier`를 반환해야 한다. 즉, 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수다.

### accumulator: 결과 컨테이너에 요소 추가하기
`accumulator` 메서드는 리듀싱 연산을 수행하는 함수를 반환한다. 

### finisher: 최종 변환값을 결과 컨테이너로 적용하기
`finisher`메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수를 반환해야 한다.

### combiner: 두 결과 컨테이너 병합
`combiner`는 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의한다.

### Characteristics 메서드
`chracteristics` 메서드는 컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환한다.

# 7. 병렬 데이터 처리와 성능
## 7.1 병렬 스트림
컬렉션에 `parallelStream`을 호출하면 병렬 스트림이 생성된다. 병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다. 따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

순차 스트림에 `parallel`메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리된다.

> 병렬 스트림은 내부적으로 ForkJoinPool을 사용한다. 기본적으로 ForkJoinPool은 프로세서 수, 즉 `Runtime.getRuntime().availableProcessors()`가 반환하는 값에 상응하는 스레드를 갖는다.

병렬화는 공짜가 아니다. 병렬화를 이용하려면 스트림을 재귀적으로 분할해야 하고, 각 서브스트림을 서로 다른 스레드의 리듀싱 연산으로 할당하고, 이들 결과를 하나의 값으로 합쳐야 한다. 멀티코어 간의 데이터 이동은 우리 생각보다 비싸다.

### 병렬 스트림의 올바른 사용법
병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 공유된 상태를 바꾸는 알고리즘을 사용하기 때문에 일어난다.

병렬 스트림과 병렬 계산에서는 공유된 가변 상태를 피해야 한다.

### 병렬 스트림 효과적으로 사용하기
- 순차 스트림과 병렬 스트림 중 어떤 것이 좋을지 모르겠다면 적절한 벤치마크로 성능을 측정해라
- 박싱을 주의하라. 되도록이면 기본형 특화 스트림을 사용하는 것이 좋다
- 순차 스트림과 병렬 스트림에서 성능이 떨어지는 연산이 있다. 특히 `limit`이나 `findFirst`처럼 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치러야 한다.
- 스트림에서 수행하는 전체 파이프라인 연산 피용을 고려하라
- 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.
- 스트림을 구성하는 자료구조가 적절한지 확인하라
- 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다
- 최종 연산의 병합 과정 비용을 살펴보라. 병합 과정의 비용이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분 결과를 합치는 과정에서 상쇄될 수 있다


## 포크/조인 프레임워크
포크/조인 프레임워크는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다. 포크/조인 프레임워크에서는 서브태스크를 스레드 풀(ForkJoinPool)의 작업자 스레드에 분산 할당하는 ExecutorService인터페이스를 구현한다.

### 작업 훔치기
한 스레드가 다른 스레드보다 자신에게 할당된 태스크를 더 빨리 처리한 경우, 다른 스레드 큐의 꼬리에서 작업을 훔쳐온다. 모든 태스크가 작업을 끝낼 때까지, 즉 모든 큐가 빌 때까지 이 과정을 반복한다. 따라서 태스크의 크기를 작게 나누어야 작업자 스레드 간의 작업부하를 비슷한 수준으로 유지할 수 있다.

---
- 컬렉션, 컬렉터, collect를 헷갈리지 않도록 주의하자
  - 컬렉션은 자료구조. `collect`는 스트림의 최종연산 메서드
  - `collect`는 전달자, 컬렉터가 수행자 느낌?
- collect와 reduce
  - 같은 기능을 구현할 수 있지만 collect 메서드는 도출하려는 결과를 누적하는 컨테이너를 바꾸도록 설계된 메서드인 반면, reduce는 두 값을 하나로 도출하는 불변형 연산이라는 점에서 의미론적인 문제가 일어난다.
- 향등함수?
  - 입력값을 그대로 출력하는 수학적 함수
