# 8. 컬렉션 API 개선
## 8.1 컬렉션 팩토리
자바 9에서는 작은 컬렉션 객체를 쉽게 만들 수 있는 몇가지 방법을 제공한다.
``` java
// 자바 9 이전
List<String> friends = new ArrayList<>();
friends.add("Raphael");
friends.add("Olivia");

// 자바 9
List<String> friends = Arrays.asList("Raphael", "Olivia");
```
리스트 요소를 갱신할 수 있지만 새 요소를 추가하거나 삭제할 수는 없다.
> `List.of`메소드로 생성한 리스트는 요소를 추가하거나 갱신할 수 없다.

> `List.of`의 다양한 오버로드 버전이 있다. 다중 요소를 받을 수 있도록 만들지 않은 이유는 내부적으로 가변 인수 버전은 추가 배열을 할당햇허 리스트로 감싼다. 따라서 배열을 할당하고 초기화하며 나중에 가비지 컬렉션을 하는 비용을 지불해야 한다. 고정된 숫자의 요소(최대 열 개)를 API로 정의함으로써 이러한 비용을 제거할 수 있다. `List.of`로 열 개 이상의 요소를 가진 리스트를 만들 수도 있지만 이 때는 가변 인수를 이용하는 메서드가 사용된다. `Set.of`, `Map.of`에서도 이와 같은 패턴이 등장한다.

### 맵 팩토리
`Map.of`팩토리 메서드에 키와 값을 번갈아 제공하는 방법으로 맵을 만들 수 있다.
``` java
Map<String, Integer> ageOfFriends = Map.of("Raphael", 30, "Olivia", 25);
```
열 개 이하의 키와 값 쌍을 가진 작은 맵을 만들 때는 이 메소드가 유용하고, 그 이상의 맵에서는 `Map.ofEntries` 팩토리 메서드를 이용하는 것이 좋다.

## 8.2 리스트와 집합 처리
- `removeIf`: 프레디케이트를 만족하는 요소를 제거한다
- `replaceAll`: 리스트에서 이용할 수 있는 기능으로, 요소를 바꾼다
- `sort`: List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다
이들 메서드는 호출한 컬렉션 자체를 바꾼다. 새로운 결과를 만드는 스트림 동작과 달리 이들 메서드는 기존 컬렉션을 바꾼다.

### 계산 패턴
- `computeIfAbsent`: 제공된 키에 해당하는 값이 없으면(없거나 널), 키를 이용해 새 값을 계산하고 맵에 추가 (키가 존재하지 않으면 값을 계산해 맵에 추가하고 키가 존재하면 기존 값을 반환)
- `computeIfPresent`: 제공된 키가 존재하면 새 값을 게산하고 맵에 추가 (키와 관련된 값이 맵에 존재하며 널이 아닐때만 새 값을 계산)
- `compute`: 제공된 키로 새 값을 계산하고 맵에 저장
``` java
friendsToMovies.computeIfAbsent("Raphael", name -> new ArrayList<>())
  .add("Star Wars");  // {Raphael: [Star Wars]}
```

### 합침
만약 맵을 합칠 때 키 값이 겹친다면 `merge` 메서드를 사용할 수 있다. 이 메서드는 중복된 키를 어떻게 합칠지 결정하는 `BiFunction`을 인수로 받는다.

## 8.4 개선된 ConcurrentHashMap
`ConcurrentHashMap`은 내부 자료구조의 특정 부분만 잠궈 동시 추가, 갱신 작업을 허용한다. 따라서 동기화된 `HashTable`버전에 비해 읽기 쓰기 연산 성능이 월등하다.

- `forEach`: 각 (키, 값) 쌍에 주어진 액션을 실행
- `reduce`: 모든 (키, 값) 쌍을 제공된 리듀스 함수를 이용해 결과로 합침
- `search`: 널이 아닌 값을 반환할때까지 각 (키, 값) 쌍에 함수를 적용

이들 연산은 ConcurrentHashMap의 상태를 잠그지 않고 연산을 수행한다는 점을 주목하자. 따라서 이들 연산에 제공한 함수는 계산이 진행되는 동안 바뀔 수 있는 객체, 값, 순서 등에 의존하지 않아야 한다.
또한 이들 연산에 병렬성 기준값을 지정해야 한다. 맵의 크기가 주어진 기준값보다 작으면 순차적으로 연산을 실행한다.

# 9. 리팩터링, 테스팅, 디버깅
람다 표현식은 익명 클래스보다 코드를 좀 더 간결하게 만든다. 또한 동작 파라미터화의 형식을 지원하므로 람다 표현식을 이용한 코드는 더 큰 유연성을 갖출 수 있다. 즉, 람다 표현식을 이용한 코드는 다양한 요구사항 변화에 대응할 수 있도록 동작을 파라미터화 한다.

- 익명 클래스를 람다 표현식으로
- 람다 표현식을 메서드 참조로
- 명령형 데이터 처리를 스트림으로

### 익명 클래스를 람다 표현식으로 리팩터링하기
하나의 추상 메서드를 구현하는 익명 클래스는 람다 표현식으로 리팩터링할 수 있다. 

하지만 모든 익명 클래스를 람다 표현식으로 변환할 수 있는 것은 아니다. 첫째, 익명 클래스에서 사용한 `this`와 `super`는 람다 표현식에서 다른 의미를 갖는다. 익명 클래스에서 `this`는 익명 클래스 자신을 가리키지만 람다에서 `this`는 람다를 감싸는 클래스를 가리킨다. 둘째, 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있다(섀도 변수). 하지만 람다 표션식으로는 변수를 가릴 수 없다.
``` java
int a =10;
Runnable r1 = () -> {
  int a = 2;  // 컴파일 에러
  System.out.println(a);
};

Runnable r2 = new Runnable() {
  public voic run() {
    int a = 2;  // shadow variable
    System.out.println(a);
  }
};
```
마지막으로 익명 클래스를 람다 표현식으로 바꾸면 콘텍스트 오버로딩에 따른 모호함이 초래될 수 있다. 익명 클래스는 인스턴스화할 때 명시적으로 형식이 정해지는 반면 형식은 콘텍스트에 따라 달라지기 때문이다.

### 람다 표현식을 메서드 참조로 리팩터링하기
람다 표현식 대신 메서드 참조를 이용하면 가독성을 높일 수 있다. 메서드 참조의 메서드명으로 코드의 의도를 명확하게 알릴 수 있기 때문이다.
``` java
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream()
  .collect(
    groupingBy(disy -> {
      if(dish.getCalories() <= 400) return CaloricLevel.DIET;
      else if(dish.getCalories() <= 700) return CaloricLevel.NORMAL;
      else return CaloricLevel.FAT;
    })
  );

// 메서드참조로 변경
Map<CaloricLovel, List<Dish>> dishesByCaloricLevel = menu.stream()
  .collect(groupingBy(Dish::getCaloricLevel));  // Dish 클래스에 getCaloricLevel 메서드가 있어야 함
```

### 명령형 데이터 처리를 스트림으로 리팩터링하기
이론적으로는 반복자를 이용한 기존의 모든 컬렉쳔 처리를 스트림 API로 바꿔야 한다. 스트림 API는 데이터 처리 파이프라인의 의도를 더 명확하게 보여주고, 쇼트서킷과 게으름이라는 강력한 최적화뿐 아니라 멀티코어 아키텍처를 활용할 수 있는 지름길을 제공하기 때문이다.

### 코드 유연성 개선
람다 표현식을 이용하면 동작 파라미터화를 쉽게 구현할 수 있으며 변화하는 요구사항에 대응할 수 있는 코드를 구현할 수 있다.

## 람다로 객체지향 디자인 패턴 리팩터링하기
다양한 패턴을 유형별로 정리한 것이 디자인 패턴이다. 디자인 패턴은 공통적인 소프트웨어 문제를 설계할 때 재사용할 수 있는, 검증된 청사진을 제공한다. 디자인 패턴은 재사용할 수 있는 부품으로 여러 가지 다리를 건설하는 엔지니어링에 비유할 수 있다.
디자인 패턴에 람다 표현식이 더해지면 색다른 기능을 발휘할 수 있다. 즉, 람다를 이용하면 이전에 디자인패턴으로 해결하던 문제를 더 쉽고 간단하게 해결할 수 있다. 또한 람다 표현식으로 기존의 많은 객체지향 디자인 패턴을 제거하거나 간결하게 재구현할 수 있다.

### 전략 패턴
전략 패턴은 한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법이다.

람다 표현식을 이용하면 전략 디자인 패턴에서 발생하는 자잘한 코드를 제거할 수 있다. 람다 표현식은 코드 조각(또는 전략)을 캡슐화한다. 즉, 람다 표현식으로 전략 디자인 패턴을 대신할 수 있다.

### 템플릿 메서드
알고리즘의 개요를 제시한 다음에 알고리즘의 일부를 고칠 수 있는 유연함을 제공해야 할 때 템플릿 메서드 디자인 패턴을 사용한다. 템플릿 메서드는 '이 알고리즘을 사용하고 싶은데 그대로는 안 되고 조금 고쳐야 하는'상황에 적합하다.

람다나 메서드 참조로 알고리즘에 추가할 다양한 컴포넌트를 구현할 수 있다. 직접 람다 표현식을 전달해 다양한 동작을 추가하해 템플릿 메서드 디자인 패턴에서 발생하는 자잘한 코드도 제거할 수 있다.

### 옵저버
어떤 이벤트가 발생했을 때 한 객체가 다른 객체 리스트에 자동으로 알림을 보내야 하는 상황에서 옵저버 디자인 패턴을 사용한다.

옵저버를 명시적으로 인스턴스화 하지 않고 람다 표현식을 직접 전달해서 실행할 동작을 지정할 수 있다. 하지만 옵저버가 상태를 가지며, 여러 메서드를 정의하는 등 복잡하다면 람다 표현식보다 기존의 클래스 구현 방식을 고수하는 것이 바람직할 수도 있다.

### 의무 체인(책임연쇄페턴)
작업 처리 객체의 체인을 만들 때는 의무 체인 패턴을 사용한다. 한 객체가 어떤 작업을 처리한 다음에 다른 객체로 결과를 전달하고, 다른 객체도 해야 할 작업을 처리한 다음에 또 다른 객체로 전달하는 식이다.

### 팩토리
인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때 팩토리 디자인 패턴을 사용한다.

---
- `UnsupportedOperationException`이 발생하는 이유가 무엇일까?
  - 고정 크기의 리스트를 만들어서 요소를 추가하거나 삭제할 수 없음
- `List.of` 리스트 팩토리를 사용하면 불변 리스트를 만들 수 있다. 따라서 선언 후 조작할 수 없고, 조작하려고 하면 예외가 발생한다.
- `Arrays.asList`와 `List.of` 중에 어떤 걸 쓰는게 좋을까
  - `List.of`는 갱신이 안되고, `Arrays.asList`는 갱신이 된다. 컬렉션이 의도치 않게 변하지 않게 하려면 `List.of`를 사용하는 것이 좋다.
- 요즘은 옵저버패턴보다 펍섭(발행구독) 패턴을 많이 쓴다.
