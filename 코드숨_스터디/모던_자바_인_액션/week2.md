# 1. 자바 8, 9, 10, 11: 무슨 일이 일어나고 있는가?

멀티코어 CPU 대중화와 같은 하드웨어적인 변화가 자바 8에도 영향을 미쳤다. 지금까지의 대부분의 자바 프로그램은 코어 중 하나만을 사용했었고, 자바 8 이전에는 나머지 코어를 활용하려면 스레드를 사용했어야 했다.

자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다. 자바 8의 가장 큰 변화 세 가지는 아래와 같다.

- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드

### 스트림 처리
스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 

자바 8에는 `java.util.stream` 패키지에 스트림 API가 추가되었다. 스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 이제 자바 8에서는 데이터베이스 질의처럼 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 또한 스트림 파이프라인을 이용해 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다.

### 동작 파라미터화로 메서드에 코드 전달하기
자바 8 이전의 자바에서는 메서드를 다른 메서드로 전달할 방법이 없었다. 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. 이러한 기능을 이론적으로 동작 파라미터화(behavior parameterization)라고 부른다.

### 병렬성과 공유 가변 데이터
다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들려면 공유된 가변 데이터(shared mutable data)에 접근하지 않아야 한다. 이러한 함수를 순수 함수, 부작용 없는 함수, 상태 없는 함수라 부른다.

## 자바 함수
프로그래밍 언어에서 함수라는 용어는 메서드 특히 정적 메서드와 같은 의미로 사용된다. 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다.

자바 8에서는 함수를 새로운 값의 형식으로 추가했다. 

프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 역사적으로 그리고 전통적으로 프로그래밍 언어에서는 이 값을 일(first-class) 값(또는 시민)이라고 부른다. 자바 프로그래밍 언어의 다양한 구조체(메서드 클래스 같은)가 값의 구조를 표현하는 데 도움이 될 수 있다. 하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다. 이렇게 전달할 수 없는 구조체는 이급 시민이다.

자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다.

### 메서드와 람다를 일급 시민으로
메서드 참조(method reference)라는 새로운 자바 8의 기능을 통해 메서드를 일급 시민으로 사용할 수 있다.

``` java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
  public boolean accept(File file) {
    return file.isHidden(); // 숨겨진 파일 필터링
  }
});

// 메서드 참조를 이용
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```
자바 8의 메서드 참조(`::`)를 이용해서 메서드를 직접 전달할 수 있다. 

자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 람다(또는 익명함수)를 포함하여 함수도 값으로 취급할 수 있다. 
``` java
// 한두 번만 사용할 메서드를 매번 정의하지 않고 익명 함수 또는 람다를 이용할 수 있다
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
```

## 스트림
스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있다. 컬렉션에서는 반복과정을 for-each 루프를 이용해 직접 처리해야 했다. 이러한 반복을 외부 반복이라고 한다. 반면 스트림 API를 이용하면 루프를 신경쓸 필요가 없다. 스프림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이와 같은 반복을 내부 반복이라고 한다.

자바 8은 스트림 API로 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제'그리고 '멀티코어 활용 어려움'이라는 두 가지 문제를 모두 해결했다.

컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면, 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다는 점을 기억하자.


## 디폴트 메서드와 자바 모듈
자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있다. 또한 자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다.

디폴트 메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능이다. 디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다. 자바 8에서는 인터페이스 규격명세에 `default`라는 새로운 키워드를 지원한다.

## 함수형 프로그래밍에서 가져온 다른 유용한 아이디어
자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 `Optional<T>` 클래스를 제공한다. Optional은 값을 갖거나 갖지 않을 수 있는 컨테이너 객체로 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메서드를 포함하고 있다. 따라서 `Optional<T>`를 사용하면 NPE를 피할 수 있다.

---

# 2. 동작 파라미터화 코드 전달하기

동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다. 동작 파라미터화란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다. 이 코드 블록은 나중에 프로그램에서 호출한다. 즉, 코드블록의 실행은 나중으로 미뤄진다

동작 파라미터화, 즉 메서드가 다양한 동작(또는 전략)을 받아서 내부적으로 다양한 동작을 수행할 수 있다.

### 익명 클래스
익명 클래스는 자바의 지역 클래스와 비슷한 개념이다. 익명 클래스는 말 그대로 이름이 없는 클래스다. 익명 클래스를 이용하면 클래스 선언과 인스턴스화를 동시에 할 수 있다. 즉석에서 필요한 구현을 만들어서 사용할 수 있다.

``` java
List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
  public boolean test(Apple apple) {
    return RED.equals(apple.getColor());
  }
});
```
하지만 익명클래스는 여전히 많은 공간을 차지하며, 많은 프로그래머가 익명 클래스 사용에 익숙하지 않다는 단점이 있다.

### 람다 표현식 사용
``` java
List<Apple> result = filterApples(inventory, (Apple apple) -> RED.equals(apple.getColor()));
```
람다 표현식을 사용하면 더 간결하면서 문제를 더 잘 설명하는 코드를 작성할 수 있다. 

동작 파라미터화 패턴은 동작을 (한 조각의 코드로) 캡슐화한 다음에 메서드로 전달해서 메서드의 동작을 파라미터화한다. 자바 API의 많은 메서드를 다양한 동작으로 파라미터화할 수 있다.

---

- 병렬 스트림이 무조건 더 나은 성능을 제공하는 것은 아니다. 조건이 맞아 떨어지고, 데이터 수가 엄청 많은 경우에만 효과를 발휘한다.
- 함수와 메서드의 차이? 사이드 이펙트가 없는 것을 함수라고 말한다.
  - 순수함수 == 정적 메서드 == 사이드 이펙트 없음
  - 클래스라는 단위를 빼고 함수만 존재할 수 있는 게 순수함수다? 자바는 함수가 무조건 클래스 안에 있어야 하니까 순수 함수일 수 없다는 의견이 있음.. 함수 자체가 아닌 익명 클래스를 넘기는 것임
- 인터페이스와 추상클래스의 차이
  - 인터페이스에서 이제 별별거 다 할 수 있는데 추상클래스를 사용해야 하는 이유가 있나..?
- 다이아몬드 상속 문제? 61p
  - 어떤 부모의 메서드를 호출해야할지 모호해지는 문제
  - 인터페이스는 다중상속이 가능하다. 근데 내가 상속받은 인터페이스에 다 동일한 이름의 디폴트 메서드가 있다. 그러고 내가 디폴트메서드를 실행하면 어떤 부모인터페이스의 디폴트메서드가 실행될까??
  - 컴파일이 안 된다.

``` kotlin
interface A {
  fun default () {
      println("test")
  }
}

interface B {
  fun default () {
      println("test2")
  }
}

class Test : A, B {
  override fun default() {
      super<A>.default()
  }
}
```
### 익명 클래스 문제
``` java
public class MeaningOfThis {
  public final int value = 4;
  
  public void doIt() {
    int value = 6;

    Runnable r = new Runnable() {
      public final int value = 5;
      
      public void run() {
        int value = 10;
        System.out.println(this.value);
      }
    }
    r.run();
  }

  public static void main(String ...args) {
    MeaningOfThis m = new MeaningOfThes();
    m.doIt(); // 5가 출력된다
  }
}
```
클래스 안의 `this`는 무조건 클래스를 가르킨다. 익명 클래스도 클래스니까 `this`는 `Runnable`을 가르키게 된다.
