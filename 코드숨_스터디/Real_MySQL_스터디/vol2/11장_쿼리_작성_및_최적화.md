# 11. 쿼리 작성 및 최적화
데이터베이스에 저장하거나 데이터베이스로부터 필요한 데이터를 가져오려면 SQL 이라는 정형화된 문장을 사용해야 한다.

데이터베이스나 테이블의 구조를 변경하기 위한 문장을 `DDL(Data Definition Language)`이라 하며, 테이블의 데이터를 조작(읽고, 쓰기)하기 위한 문장을 `DML(Data Manipulation Language)`이라고 한다.

SQL은 어떠한(What) 데이터를 요청하기 위한 언어이지, 어떻게(How) 데이터를 읽을지를 표현하는 언어는 아니다.

# 11.1 쿼리 작성과 연관된 시스템 변수
대소문자 구분, 문자열 표기 방법 등과 같은 SQL 작성 규칙은 MySQL 서버의 시스템 설정에 따라 달라진다.
## 11.1.1 SQL 모드
MySQL 서버의 `sql_mode`라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있다.

- `STRICT_ALL_TABLES` & `STRICT_TRANS_TABLES`: INSERT나 UPDATE 같이 데이터를 변경할 때 자동으로 타입 변경을 수행한다.
  - `TRANS`는 InnoDB 같이 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드(Stric Mode)를 적용한다.
  - 해당 옵션은 사용자가 원하지 않는 방향으로 값의 자동 변환이 유발될 수도 있으므로 MySQL 서버를 서비스에 적용하기 전에 반드시 활성화 할 것을 권장한다.
- `ANSI_QUOTES`: MySQL에서는 문자열 값(리터럴)을 표현하기 위해 홑따옴표와 쌍따옴표 모두 사용가능하지만, 이 설정을 활성화하면 홑따옴표만 문자열 값 표기로 사용할 수 있고, 쌍따옴표는 칼럼명이나 테이블명과 같은 식별자를 표기하는 데만 사용할 수 있다.
- `ONLY_FULL_GROUP_BY`: MySQL의 쿼리에서는 GROUP BY 절에 포함되지 않은 칼럼이라도 집합 함수의 사용 없이 그대로 SELECT 절이나 HAVING 절에 사용할 수 있다. 하지만 이 부분이 표준 SQL과 다르므로 좀 더 엄격한 규칙을 적용하고자 한다면 이 설정을 활성화할 수 있다. MySQL 8.0 부터는 이 옵션이 기본적으로 활성화되어 있다.
- `NO_ZERO_IN_DATE` & `NO_ZERO_DATE`: DATE 또는 DATETIME 타입의 칼럼에 "2020-00-00" 또는 "0000-00-00"같은 잘못된 날짜를 저장하는 것이 불가능해진다. 
- `ANSI`: MySQL 서버가 최대한 SQL 표준에 맞게 동작하게 만들어준다. 
  - "REAL_AS_FLOAT, PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, ONLY_FULL_GROUP_BY" 모드의 조합이다.
## 11.1.2 영문 대소문자 구분
MySQL 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다.

윈도우에 설치된 MySQL에서는 대소문자를 구분하지 않지만 유닉스 계열의 운영체제에서는 대소문자를 구분한다.

MySQL 서버가 운영체제와 관계없이 대소문자 구분의 영향을 받지 않게 하려면 MySQL 서버의 설정 파일에 `lower_case_tables_names` 시스템 변수를 설정하면 된다. 이 변수를 1로 설정하면 모두 소문자로만 저장되고, MySQL 서버가 대소문자를 구분하지 않게 해분다. 이 설정의 기본값은 0으로, DB나 테이블명에 대해 대소문자를 구분한다.

윈도우와 MacOS에서는 2를 설정할 수도 있다. 이 경우에는 저장은 대소문자를 구분해서 하지만 MySQL의 쿼리에서는 대소문자를 구분하지 않게 해준다.

**이러한 설정 자체를 떠나서 가능하면 초기 DB나 테이블을 생성할 때 대문자 또는 소문자만으로 통일해서 사용하는 편이 좋다.**

## 11.1.3 MySQL 예약어
예약어와 같은 키워드로 데이터베이스나 테이블, 칼럼의 이름을 지정하면 해당 칼럼이나 테이블을 SQL에서 사용하기 위해 항상 역따옴표(`` ` ``)나 쌍따옴표로 감싸야 한다.

## 11.3 MySQL 연산자와 내장 함수
### 11.3.1 리터럴 표기법 문자열
### 문자열
SQL 표준에서 문자열은 항상 홑따옴표(`'`)를 사용해서 표시하지만, MySQL에서는 쌍따옴표를 사용할 수도 있다.
``` sql
SELECT * FROM departments WHERE dept_no='d001';
SELECT * FROM departments WHERE dept_no="d001";
```
SQL 표준에서는 문자열 값에 홑따옴표가 포함돼 있을 때 홑따옴표를 두 번 연속해서 입력하면 된다. 하지만 MySQL에서는 쌍따옴표와 홑따옴표를 혼합해서 이러한 문제를 피하기도 한다.
``` sql
-- SQL 표준
SELECT * FROM departments WHERE dept_no='d''001'; -- d'001
SELECT * FROM departments WHERE dept_no='d"001'; -- d"001

-- MySQL에서만 지원
SELECT * FROM departments WHERE dept_no="d'001"; -- d'001
SELECT * FROM departments WHERE dept_no="d""001"; -- d"001
```

### 숫자
숫자 값을 상수로 SQL에 사용할 때는 다른 DBMS와 마찬가지로 따옴표(' 또는 ") 없이 숫자 값을 입력하면 된다.

문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 칼럼이면 MySQL 서버가 문자열 값을 숫자로 자동 변환한다.

```sql
SELECT * FROM tab_test WHERE number_column='10001';
SELECT * FROM tab_test WHERE string_column=10001;
```
위의 쿼리에서는 자동으로 타입 변환이 발생한다. MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행한다.

첫 번째 쿼리는 주어진 상숫값을 숫자로 변환한다. 상숫값 하나만 변환하므로 성능과 관련된 문제가 발생하지 않는다. 두 번째 쿼리는 주어진 상숫값이 숫자 값인데, 비교되는 칼럼은 문자열 칼럼이다. 이때 MySQL은 문자열 칼럼을 숫자로 변환해서 비교한다. 즉, string_column 칼럼의 모든 문자열 값을 숫자로 변환해서 비교를 수행해야 하므로 해당 칼럼에 인덱스가 있더라도 이를 이용하지 못한다.

### 날짜
다른 DBMS에서 날짜 타입을 비교하거나 INSERT하려면 문자열을 DATE 타입으로 변환하는 코드가 필요하지만, MySQL에서는 정해진 형태의 날짜 포맷으로 표기하면 MySQL 서버가 자동으로 DATE나 DATETIME 값으로 변환하기 때문에 복잡하게 `STR_TO_DATE()`같은 함수를 사용하지 않아도 된다.

### 불리언
`BOOL`이나 `BOOLEAN`이라는 타입이 있지만 사실 이것은 `TINYINT` 타입에 대한 동의어일 뿐이다.

### 11.3.2 MySQL 연산자
### 동등(Equal) 비교
다른 DBMS와 마찬가지로 `=`기호를 사용해 비교를 수행한다. MySQL은 동등 비교를 위해 `<=>`연산자도 제공한다. `<=>`연산자는 `=`와 같으며, 부가적으로 NULL 값에 대한 비교까지 수행한다.
이 연산자를 MySQL에서는 NULL-Safe 비교 연산자라고 한다.
### 부정(Not-Equal) 비교
일반적으로 `<>`연산자를 많이 사용한다. 그리고 `!=`도 Not-Equal 연산자로 사용할 수 있다. 어느 쪽을 사용해도 특별히 문제되지 않지만 통일해서 사용하는 것이 좋다.
### NOT 연산자
TRUE 또는 FALSE 연산의 결과를 반대로 만드는 연산자로 `NOT`을 사용할 수도 있고, `!`을 사용할수도 있다.
### AND와 OR 연산자
일반적으로 DBMS에서는 불리언 표현식의 결과를 결합하기 위해 `AND`나 `OR`를 사용한다. MySQL에서는 `AND`와 `OR`뿐만 아니라 `&&`와 `||`의 사용도 허용한다.
b
오라클에서는 `||`를 불리언 표현식의 결합 연산자가 아니라 문자열을 결합하는 연산자로 사용한다. 
SQL의 가독성을 높이기 위해 다른 용도로 사용될 수 있는 `&&` 연산자와 `||`연산자는 사용을 자제하는 것이 좋다.

### 나누기와 나머지 연산자
나누기 연산자는 `/`를 사용한다. 나눈 몫의 정수 부분만 가져오려면 `DIV`연산자를 사용하고, 나눈 결과 몫이 아닌 나머지를 가져오는 연산자로는 `%` 또는 `MOD` 연산자(함수)를 사용한다.
### REGEXP 연산자
문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자이다. `RLIKE`는 `REGEXP`와 똑같은 비교를 수행하는 연산자다. `REGEXP`연산자는 좌측에는 비교 대상 문자열 값 또는 문자열 칼럼을, 우측에 검증하고자 하는 정규 표현식을 사용한다.
``` sql
SELECT 'abc' REGEXP '^[x-z]';
```
`REGEXP`연산자를 문자열 칼럼 비교에 사용할 때 인덱스 레인지 스캔을 사용할 수 없다. 따라서 WHERE 조건절에 `REGEXP` 연산자를 단독으로 사용하는 것은 성능상 좋지 않다.

### LIKE 연산자
`LIKE` 연산자는 인덱스를 이용해 처리할 수도 있다. `LIKE`연산자는 와일드카드 문자인(%, _)가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔으로 사용할 수 있지만, 와일드카드가 앞쪽에 있다면 인덱스 레인지 스캔을 사용할 수 없으므로 주의해서 사용해야 한다.

### BETWEEN 연산자
`BETWEEN`연산자는 "크거나 같다"와 "작거나 같다"라는 두 개의 연산자를 하나로 합친 연산자다.

`BETWEEN`이 선형으로 인덱스를 검색해야 하는 것과는 달리 `IN`은 동등(Equal) 비교를 여러 번 수행하는 것과 같은 효과가 있다.

### IN 연산자
`IN`은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자다. 여러 개의 값이 비교되지만 범위로 검색하는 것이 아니라 여러 번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 처리된다.

### 11.3.3 MySQL 내장 함수
---
스터디에서 나온 얘기
- 대소문자 구분
  - 스터디원 모두 대문자 사용한다.

- 예약어
  - `ORDER`랑 `USER`는 예약어라 보통 `ORDERS`, `USERS`로 쓴다.
  - 예약어 충돌을 피하려면 "`(백틱, 역따옴표)"을 쓴다.

- 불리언 쓰시나요?
  - `char` 타입으로 지정하고, `Y/N`을 많이 쓴다.
  - 불리언을 쓰기도 한다.
  - `TINYINT`랑 똑같다.

- ANSI 표준
  - 표준 지키자!

- LIKE
  - `%search`는 인덱스 레인지 스캔을 사용할 수 없다. 조심해야 한다.

- BETWEEN 연산자
  - 다른 RDBMS에서는 `BETWEEN`을 쓰지 말라고 권고하기도 한다.
  - 동등비교를 쓸 수 있는 상황이면 동등비교를 쓰자.
  - `IN`을 쓰면 조회 조건을 더 좁힐 수 있다.
    - IN(subquery) 형태로 작성하면 옵티마이저가 세미 조인 최적화를 이용해 더 빠른 쿼리를 변환해서 실행한다. 
  - `NOT IN`은 인덱스 풀 스캔이다. 조심해야 한다..

- NOW와 SYSDATE의 차이
  - SYSDATE 쓰지말자..

- 시간 관련 얘기
  - 서버랑 DB 시간대를 둘 다 맞추자
  - 시스템마다 시간이 다를 경우 시간을 맞춰야한다. 그런 케이스에는 timestamp를 쓴다. timestamp는 unix시간이기 때문에 시간이 동일하다. 
