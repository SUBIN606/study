# 16. 복제
데이터베이스를 사용하고 운영할 때 가장 중요한 두 가지 요소가 바로 확장성(Scalability)과 가용성(Availability)이다. 서비스에서 발생하는 대용량 트래픽을 안정적으로 처리하기 위해서는 데이터베이스 서버의 확장이 필수적이며, 사용자가 언제든지 안정적인 서비스를 이용할 수 있게 하려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 반드시 뒷받침돼야 한다. 이 두 요소를 위해 가장 일반적으로 사용되는 기술이 바로 복제(Replication)다.

# 16.1 개요
복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말한다.

원본 데이터를 가진 서버를 `소스(Source) 서버`, 복제된 데이터를 가지는 서버를 `레플리카(Replica) 서버`라고 부른다. 소스 서버에서 데이터 및 스키마에 대한 변경이 최초로 발생하며, 레플리카 서버에서는 이러한 변경 내역을 소스 서버로부터 전달받아 자신이 가지고 있는 데이터에 반영함으로써 소스 서버에 저장된 데이터와 동기화시킨다.

일반적으로 서비스에서 사용될 DB 서버를 구축할 때는 메인으로 사용될 소스 서버 한 대와 복제를 통해 소스 서버와 동일한 데이터를 가진 레플리카 서버를 한 대 이상 함께 구축한다.

### 복제를 통해 레플리카 서버를 구축하는 이유
1. 스케일 아웃(Scale-out)

서비스의 사용자가 늘어남에 따라 DB 서버로 유입되는 트래픽이 증가해 DB 서버의 부하가 높아진다. 트래픽 증가로 인한 DB 서버의 부하가 높아지면 여러 조치를 취할 수 있겠지만 서버의 사양을 업그레이드하는 방법을 취하기도 한다. 이를 스케일 업(Scale-up)이라고 한다. 이 방법은 애플리케이션 단의 큰 변화 없이 늘어난 트래픽을 처리할 수 있다는 장점이 있지만, 일시적이라는 단점도 있다. 서버 한 대에서 처리할 수 있는 양에는 한계가 있기 때문이다.

동일한 데이터를 가진 DB 서버를 한 대 이상 더 사용할 수 있다면 애플리케이션으로부터 실행되는 쿼리들을 분산시킬 수 있을 것이다. 이 같은 방법을 스케일 아웃(Scale-out)이라고 하며, 스케일 아웃은 스케일 업 방식보다 갑자기 늘어나는 트래픽을 대응하는 데 훨씬 더 유연한 구조다.

복제를 통해 DB 서버를 스케일 아웃 함으로써 서버를 좀 더 안정적으로 운영할 수 있다.

2. 데이터 백업

실수로 데이터가 삭제되는 것을 대비하기 위해 DB 서버에 저장된 데이터들을 주기적으로 백업하는 것이 필수적이다. 백업은 보통 데이터가 저장돼 있는 DB 서버에서 백업 프로그램이 실행되어 백업을 진행한다. 동일한 서버 내에서 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용하기 때문에 백업으로 인해 DBMS에서 실행 중인 쿼리들이 영향을 받을 수 있으며, 심각한 경우 서비스에 문제가 발생할 수도 있다.

따라서 주로 복제를 사용해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행하는 방식을 사용하는 것이 좋다. 이렇게 구축된 백업용 레플리카 서버는 소스 서버에 문제가 생겼을 때를 대비한 대체 서버의 역할을 하기도 한다.

3. 데이터 분석

차세데 비즈니스 모델을 발굴하기 위해서나 서비스를 좀 더 발전시킬 수 있는 인사이트를 얻기 위해 분석용 쿼리들을 실행하기도 한다. 이러한 분석용 쿼리는 대량의 데이터를 조회하는 경우가 많고, 집계 연산을 하는 등 쿼리 자체가 굉장히 복잡하고 무거운 경우가 대부분이기 때문에 쿼리 실행에 많은 리소스를 사용한다. 이는 서비스에서 사용되는 다른 쿼리들에 영향을 줄 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋다.

4. 데이터의 지리적 분산

DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어난다. 서비스의 응답 속도는 애플리케이션 서버의 처리 속도와 더불어 이러한 서버 간의 통신 속도에도 영향을 받으므로 사용자에게 빠른 응답 속도를 제공하려면 애플리케이션 서버와 DB 서버가 가깝게 위치하는 것이 좋다. 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못한다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있다.

# 16.2 복제 아키텍처
MySQL 서버에서 발생하는 모든 변경 사항은 바이너리 로그(Binary Log)에 순서대로 기록된다. 바이너리 로그에는 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구조 변경과 계정이나 권한의 변경 정보까지 모두 저장된다. MySQL의 복제는 이 바이너리 로그를 기반으로 구현됐다.

소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤 자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버 간에 데이터 동기화가 이뤄진다.

레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일을 릴레이 로그(Relay Log)라 한다.

MySQL의 복제는 세 개의 스레드에 의해 작동한다. 이 세 스레드 중 하나는 소스 서버에, 나머지 두 개는 레플리카 서버에 존재한다.

# 16.3 복제 타입
MySQL의 복제는 소스 서버의 바이너리 로그에 기록된 변경 내역(바이너리 로그 이벤트)들을 식별하는 방식에 따라 바이너리 로그 파일 위치 기반 복제와 글로벌 트랜잭션 ID 기반 복제로 나뉜다.

## 바이너리 로그 파일 위치 기반 복제
MySQL에 복자 기능이 처음 도입됐을 때부터 제공된 방식으로, 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태를 말한다.

복제를 처음 구축할 때 소스 서버에서 발생한 각 이벤트에 대한 식별이 반드시 필요하다.

**바이너리 로그 파일 위치 기반 복제에서는 이러한 이벤트 하나하나를 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치 값(File Offest)의 조합으로 식별한다.** 레플리카 서버에서는 이처럼 각 이벤트들을 식별하고 자신의 적용 내역을 추적함으로써 복제를 일시적으로 중단할 수 있으며, 재개할 때도 자신이 마지막으로 적용했던 이벤트 이후의 이벤트들부터 다시 읽을 수 있다.

**바이너리 로그 파일 위치 기반 복제에서 또 하나 중요한 부분은 바로 복제에 참여한 MySQL 서버들이 모두 고유한 server_id 값을 가지고 있어야 한다는 점이다.** 바이너리 로그에는 각 이벤트별로 이 이벤트가 최초로 발생한 MySQL 서버를 식별하기 위한 server_id를 부가적으로 저장한다. server_id는 사용자가 서버마다 원하는 값으로 설정할 수 있으며 기본 값은 1이다.

바이너리 로그 파일 위치 기반 복제에서는 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 server_id 값과 동일한 server_id를 가지면, 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시한다. 자신의 서버에서 발생한 이벤트로 간주해서 적용하지 않는 것이다. 이 부분을 제대로 인지하지 않고 사용하면 복제가 의도한대로 동작하지 않을 수 있다.

따라서 사용자는 반드시 복제의 구성원이 되는 모든 MySQL 서버가 고유한 server_id 값을 갖도록 설정해야 한다.

- 기본적으로 MySQL 복제를 사용하려면 소스 서버에 반드시 바이너리 로그가 활성화돼있어야 한다.
  - MySQL 8.0에서는 바이너리 로그가 기본적으로 활성화돼있다.
- 복제 구성원이 되는 각 MySQL 서버가 고유한 server_id 값을 가져야 한다.
- 레플리카 서버가 소스 서버로부터 바이너리 로그를 가져오려면 소스 서버에 접속해야 하므로 접속 시 사용할 DB계정이 필요하다.(복제용 계정)
  - 복제에 사용되는 권한만 주어진 별도의 계정을 생성해 사용하는 것이 좋다.
  - 복제용 계정은 복제를 시작하기 전 소스 서버에 미리 준비돼 있어야 한다.
  - 반드시 `REPLICATION SLAVE` 권한을 가지고 있어야 한다.

소스 서버의 데이터를 레플리카 서버로 가져와 적재할 때는, MySQL 엔터프라이즈 백업이나 mysqldump 등과 같은 툴을 이용해 소스 서버에서 데이터를 내려받아 레플리카 서버로 복사하면 된다. 일반적으로 데이터가 크지 않다면 mysqldump를 많이 사용한다.

## 글로벌 트랜잭션 아이디(GTID) 기반 복제
MySQL 5.5 버전까지는 바이너리 로그 파일 위치 기반 복제 방식만 가능했다. 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 갖게 된다. 이렇게 복제를 구성하는 서버들이 서로 호환되지 않는 정보를 이용해 복제를 진행함으로써 복제의 토폴로지를 변경하는 작업은 때로 거의 불가능할 때도 많았다. 복제 토폴로지 변경은 주로 복제에 참여한 서버들 중에서 일부 서버에 장애가 발생했을 때 필요한데, 토폴로지 변경이 어렵다는 것은 그만큼 복제를 이용한 장애 복구(Failover)가 어렵다는 것을 의미한다.

복제에 참여한 전체 MySQL 서버들에서 고유하도록 각 이벤트에 부여된 식별 값을 글로벌 트랜잭션 아이디(Global Transaction Identifier, GTID)라고 하며, 이를 기반으로 복제가 진행되는 형태를 GTID 기반 복제라 한다.

바이너리 로그 파일명과 파일 내의 위치로 식별하는 것은 물리적인 방식이라 할 수 있다. 반면 GTID는 논리적인 의미로서 물리적인 파일의 이름이나 위치와는 전혀 무관하게 생성된다. **MySQL의 GTID는 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자로, 해당 트랜잭션이 발생한 서버에서 고유할뿐만 아니라 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유하다.**

GTID는 커밋되어 바이너리 로그에 기록된 트랜잭션에 한해서만 할당되며, 데이터 읽기만 수행하는 SELECT 쿼리나 혹은 sql_log_bin 설정이 비활성화돼 있는 상태에서 발생한 트랜잭션은 바이너리에 기록되지 않으므로 GTID가 할당되지 않는다.

GTID는 소스 아이디와 트랜잭션 아이디 값의 조합으로 생성된다. 소스 아이디는 트랜잭션이 발생된 소스 서버를 식별하기 위한 값으로, MySQL 서버의 server_uuid 시스템 변수 값을 사용한다. 트랜잭션 아이디는 서버에서 커밋된 트랜잭션 순서대로 부여되는 값으로 1부터 1씩 단조 증가하는 형태로 발급된다.

- server_uuid는 사용자가 별도로 설정하는 것이 아니라 MySQL 서버가 시작되면서 자동으로 부여된다.
- MySQL 서버에서 GTID를 활성화하는 것과 GTID 기반의 복제를 사용하는 것은 별개이다.
  - GTID 활성화는 GTID 복제를 위한 하나의 조건이다.
  - GTID가 비활성화돼 있다 하더라도 MySQL 서버의 재시작 없이 GTID를 활성화 할 수 있다.
  - 복제에 참여하는 모든 MySQL 서버들이 GTID가 활성화돼 있어야 한다.
  - 각 서버의 server_id 및 server_uuid가 복제 그룹 내에서 고유해야 한다.

# 16.5 복제 동기화 방식
MySQL에서는 소스 서버와 레플리카 서버 간의 복제 동기화에 대해 두 가지 방식을 제공한다. 하나는 오래전부터 사용돼온 비동기 복제(Asynchronous replication) 방식이며, 다른 하나는 MySQL 5.5 버전부터 도입된 반동기 복제(Semi-synchronous replication) 방식이다.

## 비동기 복제
MySQL의 복제는 기본적으로 비동기 방식으로 동작한다. 비동기 방식이란 소스 서버가 자신과 복제 연결된 레플리카 서버에서 변경 이벤트가 정상적으로 전달되어 적용됐는지를 확인하지 않는 방식이다.

비동기 복제 방식에서 소스 서버는 레플리카 서버로 변경 이벤트가 잘 전달됐는지, 실제로 적용됐는지 알지 못하며 이에 대한 어떠한 보장도 하지 않는다. 이로 인해 소스 서버에 장애가 발생하면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 수 있다. 즉, 누락된 트랜잭션이 존재하게 되는 것이다.

만약 소스 서버 장애로 인해 레플리카 서버를 새로운 소스 서버로 승격시키는 경우 사용자는 이 레플리카 서버가 소스 서버로부터 전달받지 못한 트랜잭션이 있는지 직접 확인하고 그런 것들이 있다면 필요 시 레플리카 서버에 수동으로 다시 적용해야 한다.

비동기 복제는 소스 서버가 레플리카 서버의 동기화 여부를 보장하지 않는다는 단점이 있지만, 소스 서버가 각 트랜잭션에 대해 레플리카 서버로 전송되는 부분을 고려하지 않기 때문에 트랜잭션 처리에 있어서도 좀 더 빠른 성능을 보이고, 레플리카 서버에 문제가 생기더라도 소스 서버에는 아무런 영향을 받지 않는다는 장점이 있다.

비동기 복제 방식은 소스 서버에 레플리카 서버를 여러 대 연결한다 해도 소스 서버에는 큰 성능 저하가 없으므로 레플리카 서버를 확장해서 읽기 트래픽을 분산하는 용도나 분석 용도 등으로 사용하기에 적합하다.

> 비동기 복제에서는 사용자가 소스 서버에서 데이터를 변경한 후 바로 레플리카 서버에서 해당 데이터를 확인했을 때 변경 전 데이터가 보여질 수도 있다. 즉각적으로 반영된 데이터를 조회해야 하는 민감한 경우에는 레플리카 서버보다는 소스 서버에서 직접 데이터를 읽어 가도록 구현하는 것이 좋다.

## 반동기 복제
반동기 복제는 비동기 복제보다 좀 더 향상된 데이터 무결성을 제공하는 복제 동기화 방식이다.

반동기 복제에서 소스 서버는 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 릴레이 로그에 기록 후 응답(ACK)을 보내면 그때 트랜잭션을 완전히 커밋시키고 클라이언트에 결과를 반환한다.

반동기 복제에서는 소스 서버에서 커밋되어 정상적으로 결과가 반환된 모든 트랜잭션들에 대해 적어도 하나의 레플리카 서버에는 해당 트랜잭션들이 전송됐음을 보장한다. 여기서 중요한 것은 "전송"됐음을 보장한다는 것이지, 실제로 복제된 트랜잭션이 레플리카 서버에 "적용"되는 것까지 보장한다는 것은 아니다. 그래서 이 동기화 방식의 이름이 반동기인 것이다.

사용자는 rpl_semi_sync_master_wait_point 시스템 변수를 통해 소스 서버가 레플리카 서버의 응답을 기다리는 지점을 제어할 수 있다. `AFTER_SYNC` 또는 `AFTER_COMMIT` 값으로 설정 가능하다.

### AFTER_SYNC
`AFTER_SYNC`로 설정된 경우 소스 서버에서는 각 트랜잭션을 바이너리 로그에 기록하고 난 후 **스토리지 엔진에 커밋하기 전 단계에서 레플리카 서버의 응답을 기다리게 된다.** 레플리카 서버로부터 정상적으로 응답이 내려오면 소스 서버는 그때 스토리지 엔진을 커밋해서 트랜잭션에 대한 처리를 완전히 끝내고, 트랜잭션을 실행한 클라이언트에 그 처리 결과를 반환한다.

### AFTER_COMMIT
`AFTER_COMMIT`으로 설정된 경우에는 소스 서버에서 트랜잭션을 바이너리 로그에 기록하고 **스토리지 엔진에서의 커밋도 진행하고 나서 최종적으로 클라이언트에 결과를 반환하기 전에 레플리카 서버의 응답을 기다린다.** 레플리카 서버로부터 응답이 내려오면 그때 클라이언트는 처리 결과를 얻고 그다음 쿼리를 실행할 수 있게 된다.

처음에는 `AFTER_COMMIT`방식으로만 동작했으나, MySQL 5.7 버전에서 `AFTER_SYNC` 방식이 새로 도입됐다. 현재 MySQL 8.0 버전에서 기본적으로 설정된 동작 방식은 `AFTER_SYNC`다.

`AFTER_SYNC` 방식은 소스 서버에 장애가 발생했을 때 팬텀 리드가 발생하지 않으며, 장애가 발생한 소스 서버에 대해 좀 더 수월하게 복구 처리가 가능하다는 장점이 있다.
`AFTER_COMMIT`에서는 트랜잭션이 스토리지 엔진 커밋까지 처리된 후 레플리카 서버의 응답을 기다리기 때문에 다른 세션에서도 조회가 가능하다. 이로 인해 소스 서버가 어떤 트랜잭션에 대해 스토리지 엔진 커밋 후 레플리카 서버로부터 아직 응답을 기다리고 있는 상황에서 소스 서버에 장애가 발생하면 사용자는 이후 새로운 소스 서버로 승격된 레플리카 서버에서 데이터를 조회할 때 자신이 이전 소스 서버에서 조회했던 데이터를 보지 못할 수도 있다. 즉, 팬텀 리드(Phantom Read)를 겪을 수 있다.

`AFTER_SYNC`가 좀 더 데이터 무결성이 강화된 방식이라고 할 수 있다.

반동기 봊게는 비동기 방식과 비교했을 때 트랜잭션 처리 속도가 더 느릴 수 있다. 최소 레플리카 서버로 응답을 요청하고 전달받기까지의 네트워크 왕복 시간만큼 더 걸린다고 할 수 있으며, 응답이 늦어지면 그만큼 트랜잭션 처리가 더 지연될 수 있다. 따라서 반동기 복제는 물리적으로 가깝게 위치한 레플리카 서버와의 복제에 더 적합하다고 할 수 있다.

# 16.6 복제 토폴로지
MySQL의 복제는 사용자가 쉽고 간단하게 설정 가능하며, 구성 형태 또한 사용자의 필요에 맞게 원하는 형태로 자유롭게 구성할 수 있다. MySQL 5.7 버전부터는 멀티 소스 복제 기능이 도입되어 하나의 레플리카 서버가 둘 이상의 소스 서버를 가질수도 있게 됐다.

### 싱글 레플리카 복제 구성
하나의 소스 서버에 하나의 레플리카 서버만 연결돼 있는 복제 형태를 말한다. 가장 기본적인 형태로, 제일 많이 사용되는 형태다.

이러한 형태에서는 보통 애플리케이션 서버는 소스 서버에만 직접적으로 접근해 사용하고, 레플리카 서버에는 접근하지 않는다. 레플리카 서버는 소스 서버에서 장애가 발생했을 때 사용될 수 있는 예비 서버 및 데이터 백업 수행을 위한 용도로 많이 사용된다.

이렇게 소스 서버와 레플리카 서버가 일대일로 구성된 형태에서는 레플리카 서버를 정말 예비용 서버로서만 사용하는 게 제일 적합하다고 할 수 있다. 서비스와 연관이 없는 배치 작업이나, 어드민 툴에서 사용되는 쿼리들은 레플리카 서버에서 실행되도록 구현해도 무방하다.

### 멀티 레플리카 복제 구성
하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태다. 보통 싱글 레플리카 복제 구성에서 추가적인 용도를 위해 여분의 레플리카 서버가 더 필요해졌을 때 자주 사용된다.

처음에는 싱글 레플리카 복제 구성으로 구축하고, 트래픽이 크게 증가하면서 소스 서버 한 대에서만 쿼리 요청을 처리하기에 벅찰 때, 이렇게 증가한 쿼리 요청의 대부분은 쓰기보다 읽기 요청이 더 많으므로 사용자는 멀티 레플리카 형태로 복제 구성을 전환해 읽기 요청 처리를 분산할 수 있다.

배치나 통계, 분석 등의 여러 작업이 하나의 MySQL 서버 내에 있는 데이터에 대해 수행돼야 하는 경우에도 멀티 레플리카 형태로 복제를 구축해 용도별로 하나씩 레플리카 서버를 나눠 전용으로 사용하게 할 수도 있다.

레플리카 서버로 서비스 읽기 요청이 들어오는 경우 해당 레플리카 서버는 소스 서버만큼 중요해지며, 그 외 다른 용도로 사용되는 레플리카 서버들도 지정된 시간 내에 쿼리 처리가 반드시 수행돼야 하는 등의 요건이 있을 수 있다. 따라서 이러한 레플리카 서버들은 장애가 발생했을 때 최대한 빠르게 복구돼야 한다. 이 같은 상황을 대비해 대체 서버 및 백업 수행 용도 외에는 최소한의 용도로만 사용되는 예비용 서버 한 대를 남겨놓는 것이 좋다. 이렇게 예비용으로 남겨진 서버는 소스 서버의 대체 서버 겸 다른 레플리카 서버의 대체 서버로도 사용할 수 있다.

### 체인 복제 구성
멀티 레플리카 복제 구성에서 레플리카 서버가 너무 많아 소스 서버의 성능에 악영향이 예상된다면 1:M:M 구조의 체인 복제 구성을 고려해 볼 수 있다.

### 듀얼 소스 복제 구성
두 개의 MySQL 서버가 서로 소스 서버이자 레플리카 서버로 구성돼 있는 형태다.

듀얼 소스 구성은 두 MySQL 서버 모두 쓰기가 가능하다는 것이 제일 큰 특징이며, 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 양쪽에서 쓰기가 발생하지만 두 서버는 서로 동일한 데이터를 갖게 된다.

### 멀티 소스 복제 구성
하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태다.

멀티 소스 복제 기능은 MySQL 5.7.6 버전에서 처음 도입됐다. 그전까지는 하나의 레플리카 서버는 단 하나의 소스 서버만 복제 연결을 할 수 있었기 때문에 텅스텐(Tungsten) 같은 별도의 오픈소스 툴을 사용해 멀티 소스를 구현하곤 했다.

- 여러 MySQL 서버에 존재하는 각기 다른 데이터를 하나의 MySQL 서버로 통합
- 여러 MySQL 서버에 샤딩돼 있는 테이블 데이터를 하나의 테이블로 통합
- 여러 MySQL 서버의 데이터를 모아 하나의 MySQL 서버에서 백업을 수행

하기 위한 목적으로 사용된다.


