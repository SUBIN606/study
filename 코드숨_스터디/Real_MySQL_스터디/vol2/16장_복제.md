# 16. 복제
데이터베이스를 사용하고 운영할 때 가장 중요한 두 가지 요소가 바로 확장성(Scalability)과 가용성(Availability)이다. 서비스에서 발생하는 대용량 트래픽을 안정적으로 처리하기 위해서는 데이터베이스 서버의 확장이 필수적이며, 사용자가 언제든지 안정적인 서비스를 이용할 수 있게 하려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 반드시 뒷받침돼야 한다. 이 두 요소를 위해 가장 일반적으로 사용되는 기술이 바로 복제(Replication)다.

# 16.1 개요
복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말한다.

원본 데이터를 가진 서버를 `소스(Source) 서버`, 복제된 데이터를 가지는 서버를 `레플리카(Replica) 서버`라고 부른다. 소스 서버에서 데이터 및 스키마에 대한 변경이 최초로 발생하며, 레플리카 서버에서는 이러한 변경 내역을 소스 서버로부터 전달받아 자신이 가지고 있는 데이터에 반영함으로써 소스 서버에 저장된 데이터와 동기화시킨다.

일반적으로 서비스에서 사용될 DB 서버를 구축할 때는 메인으로 사용될 소스 서버 한 대와 복제를 통해 소스 서버와 동일한 데이터를 가진 레플리카 서버를 한 대 이상 함께 구축한다.

### 복제를 통해 레플리카 서버를 구축하는 이유
1. 스케일 아웃(Scale-out)

서비스의 사용자가 늘어남에 따라 DB 서버로 유입되는 트래픽이 증가해 DB 서버의 부하가 높아진다. 트래픽 증가로 인한 DB 서버의 부하가 높아지면 여러 조치를 취할 수 있겠지만 서버의 사양을 업그레이드하는 방법을 취하기도 한다. 이를 스케일 업(Scale-up)이라고 한다. 이 방법은 애플리케이션 단의 큰 변화 없이 늘어난 트래픽을 처리할 수 있다는 장점이 있지만, 일시적이라는 단점도 있다. 서버 한 대에서 처리할 수 있는 양에는 한계가 있기 때문이다.

동일한 데이터를 가진 DB 서버를 한 대 이상 더 사용할 수 있다면 애플리케이션으로부터 실행되는 쿼리들을 분산시킬 수 있을 것이다. 이 같은 방법을 스케일 아웃(Scale-out)이라고 하며, 스케일 아웃은 스케일 업 방식보다 갑자기 늘어나는 트래픽을 대응하는 데 훨씬 더 유연한 구조다.

복제를 통해 DB 서버를 스케일 아웃 함으로써 서버를 좀 더 안정적으로 운영할 수 있다.

2. 데이터 백업

실수로 데이터가 삭제되는 것을 대비하기 위해 DB 서버에 저장된 데이터들을 주기적으로 백업하는 것이 필수적이다. 백업은 보통 데이터가 저장돼 있는 DB 서버에서 백업 프로그램이 실행되어 백업을 진행한다. 동일한 서버 내에서 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용하기 때문에 백업으로 인해 DBMS에서 실행 중인 쿼리들이 영향을 받을 수 있으며, 심각한 경우 서비스에 문제가 발생할 수도 있다.

따라서 주로 복제를 사용해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행하는 방식을 사용하는 것이 좋다. 이렇게 구축된 백업용 레플리카 서버는 소스 서버에 문제가 생겼을 때를 대비한 대체 서버의 역할을 하기도 한다.

3. 데이터 분석

차세데 비즈니스 모델을 발굴하기 위해서나 서비스를 좀 더 발전시킬 수 있는 인사이트를 얻기 위해 분석용 쿼리들을 실행하기도 한다. 이러한 분석용 쿼리는 대량의 데이터를 조회하는 경우가 많고, 집계 연산을 하는 등 쿼리 자체가 굉장히 복잡하고 무거운 경우가 대부분이기 때문에 쿼리 실행에 많은 리소스를 사용한다. 이는 서비스에서 사용되는 다른 쿼리들에 영향을 줄 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋다.

4. 데이터의 지리적 분산

DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어난다. 서비스의 응답 속도는 애플리케이션 서버의 처리 속도와 더불어 이러한 서버 간의 통신 속도에도 영향을 받으므로 사용자에게 빠른 응답 속도를 제공하려면 애플리케이션 서버와 DB 서버가 가깝게 위치하는 것이 좋다. 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못한다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있다.

# 16.2 복제 아키텍처
MySQL 서버에서 발생하는 모든 변경 사항은 바이너리 로그(Binary Log)에 순서대로 기록된다. 바이너리 로그에는 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구조 변경과 계정이나 권한의 변경 정보까지 모두 저장된다. MySQL의 복제는 이 바이너리 로그를 기반으로 구현됐다.

소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤 자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버 간에 데이터 동기화가 이뤄진다.

레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일을 릴레이 로그(Relay Log)라 한다.

MySQL의 복제는 세 개의 스레드에 의해 작동한다. 이 세 스레드 중 하나는 소스 서버에, 나머지 두 개는 레플리카 서버에 존재한다.

# 16.3 복제 타입
MySQL의 복제는 소스 서버의 바이너리 로그에 기록된 변경 내역(바이너리 로그 이벤트)들을 식별하는 방식에 따라 바이너리 로그 파일 위치 기반 복제와 글로벌 트랜잭션 ID 기반 복제로 나뉜다.

## 바이너리 로그 파일 위치 기반 복제
MySQL에 복자 기능이 처음 도입됐을 때부터 제공된 방식으로, 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태를 말한다.

복제를 처음 구축할 때 소스 서버에서 발생한 각 이벤트에 대한 식별이 반드시 필요하다.

**바이너리 로그 파일 위치 기반 복제에서는 이러한 이벤트 하나하나를 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치 값(File Offest)의 조합으로 식별한다.** 레플리카 서버에서는 이처럼 각 이벤트들을 식별하고 자신의 적용 내역을 추적함으로써 복제를 일시적으로 중단할 수 있으며, 재개할 때도 자신이 마지막으로 적용했던 이벤트 이후의 이벤트들부터 다시 읽을 수 있다.

**바이너리 로그 파일 위치 기반 복제에서 또 하나 중요한 부분은 바로 복제에 참여한 MySQL 서버들이 모두 고유한 server_id 값을 가지고 있어야 한다는 점이다.** 바이너리 로그에는 각 이벤트별로 이 이벤트가 최초로 발생한 MySQL 서버를 식별하기 위한 server_id를 부가적으로 저장한다. server_id는 사용자가 서버마다 원하는 값으로 설정할 수 있으며 기본 값은 1이다.

바이너리 로그 파일 위치 기반 복제에서는 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 server_id 값과 동일한 server_id를 가지면, 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시한다. 자신의 서버에서 발생한 이벤트로 간주해서 적용하지 않는 것이다. 이 부분을 제대로 인지하지 않고 사용하면 복제가 의도한대로 동작하지 않을 수 있다.

따라서 사용자는 반드시 복제의 구성원이 되는 모든 MySQL 서버가 고유한 server_id 값을 갖도록 설정해야 한다.

- 기본적으로 MySQL 복제를 사용하려면 소스 서버에 반드시 바이너리 로그가 활성화돼있어야 한다.
  - MySQL 8.0에서는 바이너리 로그가 기본적으로 활성화돼있다.
- 복제 구성원이 되는 각 MySQL 서버가 고유한 server_id 값을 가져야 한다.
- 레플리카 서버가 소스 서버로부터 바이너리 로그를 가져오려면 소스 서버에 접속해야 하므로 접속 시 사용할 DB계정이 필요하다.(복제용 계정)
  - 복제에 사용되는 권한만 주어진 별도의 계정을 생성해 사용하는 것이 좋다.
  - 복제용 계정은 복제를 시작하기 전 소스 서버에 미리 준비돼 있어야 한다.
  - 반드시 `REPLICATION SLAVE` 권한을 가지고 있어야 한다.

소스 서버의 데이터를 레플리카 서버로 가져와 적재할 때는, MySQL 엔터프라이즈 백업이나 mysqldump 등과 같은 툴을 이용해 소스 서버에서 데이터를 내려받아 레플리카 서버로 복사하면 된다. 일반적으로 데이터가 크지 않다면 mysqldump를 많이 사용한다.

## 글로벌 트랜잭션 아이디(GTID) 기반 복제
MySQL 5.5 버전까지는 바이너리 로그 파일 위치 기반 복제 방식만 가능했다. 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 갖게 된다. 이렇게 복제를 구성하는 서버들이 서로 호환되지 않는 정보를 이용해 복제를 진행함으로써 복제의 토폴로지를 변경하는 작업은 때로 거의 불가능할 때도 많았다. 복제 토폴로지 변경은 주로 복제에 참여한 서버들 중에서 일부 서버에 장애가 발생했을 때 필요한데, 토폴로지 변경이 어렵다는 것은 그만큼 복제를 이용한 장애 복구(Failover)가 어렵다는 것을 의미한다.

복제에 참여한 전체 MySQL 서버들에서 고유하도록 각 이벤트에 부여된 식별 값을 글로벌 트랜잭션 아이디(Global Transaction Identifier, GTID)라고 하며, 이를 기반으로 복제가 진행되는 형태를 GTID 기반 복제라 한다.

바이너리 로그 파일명과 파일 내의 위치로 식별하는 것은 물리적인 방식이라 할 수 있다. 반면 GTID는 논리적인 의미로서 물리적인 파일의 이름이나 위치와는 전혀 무관하게 생성된다. **MySQL의 GTID는 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자로, 해당 트랜잭션이 발생한 서버에서 고유할뿐만 아니라 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유하다.**

GTID는 커밋되어 바이너리 로그에 기록된 트랜잭션에 한해서만 할당되며, 데이터 읽기만 수행하는 SELECT 쿼리나 혹은 sql_log_bin 설정이 비활성화돼 있는 상태에서 발생한 트랜잭션은 바이너리에 기록되지 않으므로 GTID가 할당되지 않는다.

GTID는 소스 아이디와 트랜잭션 아이디 값의 조합으로 생성된다. 소스 아이디는 트랜잭션이 발생된 소스 서버를 식별하기 위한 값으로, MySQL 서버의 server_uuid 시스템 변수 값을 사용한다. 트랜잭션 아이디는 서버에서 커밋된 트랜잭션 순서대로 부여되는 값으로 1부터 1씩 단조 증가하는 형태로 발급된다.

- server_uuid는 사용자가 별도로 설정하는 것이 아니라 MySQL 서버가 시작되면서 자동으로 부여된다.
- MySQL 서버에서 GTID를 활성화하는 것과 GTID 기반의 복제를 사용하는 것은 별개이다.
  - GTID 활성화는 GTID 복제를 위한 하나의 조건이다.
  - GTID가 비활성화돼 있다 하더라도 MySQL 서버의 재시작 없이 GTID를 활성화 할 수 있다.
  - 복제에 참여하는 모든 MySQL 서버들이 GTID가 활성화돼 있어야 한다.
  - 각 서버의 server_id 및 server_uuid가 복제 그룹 내에서 고유해야 한다.

# 16.5 복제 동기화 방식
MySQL에서는 소스 서버와 레플리카 서버 간의 복제 동기화에 대해 두 가지 방식을 제공한다. 하나는 오래전부터 사용돼온 비동기 복제(Asynchronous replication) 방식이며, 다른 하나는 MySQL 5.5 버전부터 도입된 반동기 복제(Semi-synchronous replication) 방식이다.
