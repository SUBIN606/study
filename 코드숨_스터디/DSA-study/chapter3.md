## 빅 오 표기법

- 알고리즘의 효율성을 쉽게 분류하고 이해시킬 수 있다.
- 빅 오는 특정 방식으로 알고리즘에 필요한 **단계 수를 고려**함으로써 일관성을 유지한다.
- 원소가 N개일 때 알고리즘에 몇 단계가 필요한가에 대한 답이다.
- **데이터가 늘어날 때 알고리즘의 성능이 어떻게 바뀌는 지**를 뜻한다.

### (3.1) 빅 오: 원소가 N개일 때 몇 단계가 필요할까?

- 선형 검색 알고리즘을 빅 오 표기법으로 표현해보고, 왜 그런지 설명해보라.

  `O(N)` 으로 표현할 수 있다. 선형 검색은 원소가 N개 있다고 가정할 때 N개의 원소를 모두 검색하는 방법이다. 항상 원소의 개수만큼 단계를 거치고, 이러한 알고리즘을 빅 오 표기법으로는 ‘오 N’이라고 한다.
  그리고 O(N)인 알고리즘을 선형 시간을 갖는 알고리즘이라고도 부른다.

- 배열의 읽기는 빅 오 표기법으로 표기하면 어떻게 되는가?

  배열의 읽기는 원소가 몇 개든지 항상 한 단계만 걸린다. 그래서 `O(1)` 이라고 표현할 수 있다. O(1)은 가장 빠른 알고리즘 유형으로 분류한다. 데이터가 증가해도 단계 수가 증가하지 않기 때문이다.
  O(1) 알고리즘은 상수 시간을 갖는 알고리즘이라고도 표현한다.

### (3.2) 빅 오의 본질

- 빅 오의 본질이란 무엇인가?

  데이터가 늘어날 때 알고리즘의 성능이 어떻게 바뀌는 지를 의미한다. 빅 오는 단순히 알고리즘에 필요한 단계 수만 알려주는 것이 아니라 **데이터가 늘어날 때 단계 수가 어떻게 증가 하는지**를 설명한다.

### (3.2.1) 빅 오의 본질 더 파고들기

- 항상 100단계가 걸리는 상수 시간 알고리즘이 O(N)인 알고리즘보다 성능이 우수한가? 우수하다면 그 이유를 설명해보라.

  상수 시간 알고리즘은 데이터 원소가 몇 개든지 항상 100단계가 걸린다. O(N)알고리즘은 항상 데이터 원소개수 만큼의 단계가 걸린다. 만약 데이터 원소 개수가 100개보다 적다면 O(N)이 더 적은 단계를 거치겠지만, 원 소 개수가 100개를 넘어서면 O(N)알고리즘이 더 많은 단계가 걸린다.
  데이터가 증가할수록 O(N)이 O(1)알고리즘보다 덜 효율적인 지점에 반드시 다다르게 된다.

### (3.2.2) 같은 알고리즘, 다른 시나리오

- 선형 검색의 최선의 시나리오와 최악의 시나리오를 빅 오 표기법으로 표현해보라.

  선형 검색의 최선의 시나리오는 검색 하려는 값을 첫 번째 단계에서 찾은 경우로 O(1)이 되고, 최악의 시나리오는 검색 하려는 값을 포함하지 않거나 마지막에 있는 경우로 O(N)이 된다.

최악의 시나리오에서 알고리즘이 얼마나 비효율적인지 정확히 알면 최악을 대비함과 동시에 알고리즘의 선택에 중요한 영향을 미칠 수 있다.

### (3.3) 세 번째 유형의 알고리즘

- 이진 검색의 빅 오 표기법은 무엇이며, 왜그런가?

  이진 검색은 데이터가 두 배로 증가할 때 마다 한 단계씩 늘어나는 알고리즘이다. 빅 오 표기법은 `O(logN)` 이다.

### (3.4) 로가리즘

### (3.5) O(logN) 해석

원소가 하나가 될 때까지 데이터 원소를 계속해서 반으로 줄이는 만큼의 단계 수가 걸린다는 뜻이다.
