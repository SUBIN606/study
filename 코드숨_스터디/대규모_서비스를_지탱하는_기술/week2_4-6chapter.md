# 2주차 스터디
# 4. 분산을 고려한 MySQL 운용
- OS 캐시 활용
- 적절한 인덱스 설정
- 확장을 전제로 한 설계

## 인덱스를 올바르게 운용하기
MySQL에는 인덱스라는 기능이 있어서 인덱스를 사용해서 데이터를 검색할 수 있게 되고 빨라진다. MySQL 뿐만 아니라 RDBMS에는 이런 구조가 마련되어 있다. 이러한 인덱스를 적절하게 설정하는 것이 매우 중요하다.

### OS 캐시 활용
전체 데이터 크기에 주의해서 데이터량이 물리 메모리보다 가능한 한 적어지도록 유지하고, 메모리가 부족할 경우에는 증설한다.

MySQL에서는 `create table`로 스키마를 결정한다. 이 스키마는 보통 마음대로 설계하는 경우가 많겠지만, 대용량이 되면 스키마의 중요성이 높아진다.

서비스를 설계하는 초기단계부터 그렇게까지 깊게 생각할 필요는 없지만, 어느정도 규모가 있는 서비스가 되면 컬럼 변경, 스키ㅣ마 변경에도 그에 상응하는 주의를 기울여야만 한다.

대량의 데이터를 저장하려는 테이블은 레코드가 가능한 한 작아지도록 컴팩트하게 설계해야 한다. 

### 인덱스의 중요성
알고리즘, 데이터 구조에서 탐색을 할 때는 기본적으로 트리(탐색트리)가 널리 사용된다. 인덱스는 주로 탐색을 빠르게 하기 위한 것으로, 그 내부 데이터 구조로는 트리가 사용된다.

MySQL의 인덱스는 기본적으로 B+트리(B Plus Tree)라는 데이터 구조다. B트리는 트리를 구성하는 각 노드가 여러 개의 자식을 가질 수 있는 다분트리이다. 또한 데이터 삽입이나 삭제를 반복한 경우에도 트리의 형태에 치우침이 생기지 않는 평형 트리이기도 하다. B트리는 하드디스크 상에 구축하기에 알맞은 데이터 구조이므로 DB에서 자주 사용된다.

B트리는 각 노드를 하나의 블록에 모아 저장되도록 구성할 수 있으므로 디스크 Seek 발생 횟수를 노드를 찾아갈 때만으로 최소화 할 수 있다. OS가 한 번에 읽어내서 메모리에 캐싱하게 되므로 같은 노드 내의 데이터는 디스크 Seek 없이 탐색할 수 있다. (B+Tree는 DB 데이터 저장에 좀 더 최적화된 구조이다)

MySQL에서 인덱스를 만들면 B+트리에 의한 트리 데이터 구조가 생긴다. 따라서 인덱스를 이용하면 탐색에서 인덱스의 트리를 순회하기 때문에 더 빠르다.

대규모가 되면 될수록 인덱스를 준비해놓느냐 아니냐에 따라 차이가 나게 된다.

> MySQL은 레코드 총 건수를 보고 인덱스를 사용하지 않는 편이 더 빠르다고 판단되면, 사용하지 않는 최적화 작업을 수행하기도 한다.

## MySQL의 분산
MySQL에는 기본 기능으로 레플리케이션(replication) 기능이 있다. 레플리케이션이란 마스터를 정하고, 마스터를 뒤따르는 서버(슬레이브)를 정해두면, 마스터에 쓴 내용을 슬레이브가 폴링해서 동일한 내용으로 자신을 갱신하는 기능이다. 즉, 슬레이브는 마스터의 레플리카가 되는 것이다. 이렇게 해서 동일한 내용의 서버를 여러 대 마련할 수가 있다.

이 때 슬레이브로는 select 등 참조 쿼리만 사용하고, 갱신 쿼리는 마스터에만 사용한다. 만약 갱신 쿼리를 슬레이브로 던지게 되면 슬레이브와 마스터 간 내용을 동기화 할 수 없게된다. MySQL은 마스터와 슬레이브 간 내용의 불일치를 감지하면 레플리케이션을 중지해버린다. 따라서 갱신은 반드시 마스터에서만 이뤄지도록 한다.

마스터/슬레이브 구조에서는 마스터를 분산할 수 없다는 문제가 있다. 즉, 참조계열 쿼리는 여러 대의 슬레이브 서버로 분산이 가능하지만 갱신계열 쿼리는 분산할 수 없다. 그리고 마스터의 다중화에 대한 문제도 있다. 하지만 웹 애플리케이션의 특성상 90%이상이 참조계열 쿼리이고, 쓰기는 상대적으로 훨씬 적다. 따라서 웹 애플리케이션에서는 참조계열에 비하면 마스터가 병목이 되어 곤란한 상황이 발생하는 경우는 그리 많지 않다.

하지만 드물게 마스터에 엄청난 쓰기 작업이 발생하는 애플리케이션을 개발해야 하는 경우도 있다. 이런 경우에도 테이블을 분할해서 테이블 크기를 작게한다. 분할로 인해 쓰기 작업이 분산되고, 테이블 파일이 분산되면 동일 호스트 내에서 여러 디스크로 분산시킬 수 있으며, 서로 다른 서버로 분산할 수도 있기 때문이다. 아니면 RDBMS가 아닌 다른 기술을 사용하는 방법도 있다.

## MySQL의 스케일 아웃과 파티셔닝
MySQL의 기본적인 전략으로는 데이터가 메모리에 올라가는 크기라면 메모리에 올리고, 올라가지 않으면 메모리를 증설하는 것이다. 또한 인덱스도 적절히 사용해야 한다. 메모리 증설이 불가능하다면 파티셔닝을 해야 한다.

파티셔닝(테이블 분할)이란 테이블A와 테이블B를 서로 다른 서버에 놓아서 분산하는 방법이다. 파티셔닝은 국소성을 활용해서 분산할 수 있으므로 캐시가 유효하고, 따라서 파티셔닝은 효과적이다.

하지만 파티셔닝은 운용이 복잡해지고, 고장률이 높아진다는 문제가 있다. 

# 5. 대규모 데이터 처리 실전 입문
전문 검색이나 유사문서계열 탐색, 데이터마이닝 같은 애플리케이션에서는 광범위한 데이터에 액세스한다. 대량의 데이터 내의 여기저기 혹은 대부분에 액세스해서 계산해가므로 애초에 데이터 내에서 이 부분만이라고 절단할 수가 없다. 통계처리나 검색이 그런 경우가 많다.

## 용도특화형 인덱싱
배치 처리로 RDBMS에서 데이터를 추출해서 별도의 인덱스 서버와 같은 것을 만들고, 이 인덱스 서버에 웹 애플리케이션에서 RPC(Remote Procedure Call) 등으로 액세스 하는 방법을 사용한다.

RDBMS는 데이터를 정렬하거나, 통계처리가 가능하거나, JOIN 하는 등 범용적인 용도로 만들어져 있다. 즉, 다양한 목적에 사용할 수 있도록 만들어진 것이다. 뭔가 특정한 목적으로만 사용하고자 할 때에는 특정한 목적으로만 사용할 수 있도록 튜닝한 데이터 구조를 사용하면 압도적으로 빠르다. 이것이 바로 용도특화형 인덱싱이다.

---
스터디에서 나눈 내용
- 91p 정규화 부분이 기존에 알고 있던 정규화 방법과 달라서 신기했다. 이런식으로 할 수 있다는 것을 알게 됐다.
- 이 책이 꽤 오래 되었는데도 대용량 서비스에서 MySQL을 사용하는게 흥미로웠다. 몇 년 전만 해도 대용량 서비스에서는 오라클을 사용해야 한다는 인식이 있었는데..
- 마스터/슬레이브 구조 (현재는 프라이머리/레플리카) 
  - 책에서 프라이머리를 하나 두고, 레플리카를 늘려라 라고 말하지만.. 요즘은 프라이머리를 늘려서 쓰는 방법도 많이 쓴다
- 2010년대 후반부터 NoSQL이 엄청 각광받았다. 책에서는 언급이 없지만, NoSQL을 사용하는 것도 좋다.
- 처음부터 파티셔닝을 염두에 두고 하나?
  - 요구사항에 연간, 월간, 일간 통계가 필요하고 분명히 대용량으로 쌓일 것 같다면 바로 파티셔닝은 안하지만, 나중에 파티셔닝 하기 용이하게 PK를 설계한다.


