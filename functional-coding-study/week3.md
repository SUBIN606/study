> 3주차는 챕터 6 ~ 8을 읽고 스터디를 진행한다.

# 챕터6. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

- 중첩된 데이터란?

  - 데이터 구조 안에 데이터 구조가 있는 경우 데이터가 중첩(nested)되었다고 말한다.
  - 깊이 중첩(deeply nested)되었다는 말은 중첩이 이어진다는 말이다.
  - 어떤 객체가 객체 안에 또 다시 배열 안에, 객체 안에 있는 것처럼 중첩은 계속 이어질 수 있다.

- 동작을 읽기, 쓰기로 분류하는 기준은 무엇인가?

  - 읽기 동작은 데이터를 바꾸지 않고 정보를 꺼내는 것이다. 데이터가 바뀌지 않기 때문에 다루기 쉽다.
    - 만약 인자에만 의존해 정보를 가져오는 읽기 동작이라면 계산이라 할 수 있다.
  - 쓰기 동작은 어떻게든 데이터를 바꾼다. 바뀌는 값은 어디서 사용될지 모르기 때문에 바뀌지 않도록 원칙이 필요하다.
    - 그래서 쓰기 동작은 불변성 원칙에 따라 구현해야 하며, 카피-온-라이트 방식을 사용해야 한다.

- 카피-온-라이트 원칙 세 단계는?
  - 복사본을 만들고, 복사본을 변경하고, 복사본을 리턴한다.

```javascript
function add_element_last(array, elem) {
  let new_array = array.slice(); // 1. 복사본 만들기
  new_array.push(elem); // 2. 복사본 바꾸기
  return new_array; // 3. 복사본 리턴하기
}
```

> 위의 함수는 데이터를 바꾸지 않았고 정보를 리턴했기 때문에 읽기 동작에 해당한다.

- 쓰기와 읽기를 모두 하는 동작의 접근방법 두 가지?
  - 어떤 동작은 읽고 변경하는 일을 동시에 한다. 이런 동작은 값을 변경하고 리턴한다.
  - 읽기와 쓰기 함수로 각각 분리하거나, 함수에서 값을 두 개 리턴한다.
- 읽기와 쓰기를 분리하면 좋은 점이 무엇인가?
  - 분리된 함수를 따로 쓸 수 있기 때문에 더 좋은 접근 방법이다. 선택해서 함수를 쓸 수 있다.

```javascript
function first_element(array) {
  return array[0]; // 그냥 배열의 첫 번째 항목을 리턴하는 함수. 이 함수는 계산이다.
}

// 카피-온-라이트로 구현한 쓰기 동작
function drop_first(array) {
  let array_copy = array.slice();
  array_copy.shift();
  return array_copy;
}

// 값을 두 개 리턴하는 함수로 만들기
function shift(array) {
  return {
    first: first_element(array),
    array: drop_first(array),
  };
}
```

- 쓰기와 액션의 관계?

  - 변경 가능한 데이터를 읽는 것은 액션이다. 쓰기는 데이터를 변경 가능한 구조로 만든다.
  - 불변 데이터 구조를 읽는 것은 계산이다. **쓰기를 읽기로 바꾼다는 것은 데이터 구조를 불변형으로 만드는 것이고, 불변형으로 만들수록 코드에 더 많은 계산이 생기고 액션은 줄어든다.**

- 얕은 복사란?

  - 데이터 구조의 최상위 단계만 복사하는 것을 얕은 복사(shallow copy)라고 한다. 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만든다. 이것을 구조적 공유(structural sharing)라고 한다.
  - 데이터 구조를 복사할 때 최대한 많은 구조를 공유한다. 그래서 더 적은 메모리를 사용하고 결국 가비지 콜렉터의 부담을 줄여준다.
  - 예를 들어 객체가 들어 있는 배열이 있다면 얕은 복사는 배열만 복사하고 안에 있는 객체는 참조로 공유한다.

- 중첩된 쓰기를 읽기로 바꾸는 방법?
  - 중첩된 쓰기도 중첩되지 않은 쓰기와 같은 패턴을 사용한다. 복사본을 만들고 변경한 뒤 복사본을 리턴한다. 중첩된 항목에 또 다른 카피-온-라이트를 사용하는 부분만 다르다.
  - 중첩된 모든 데이터 구조가 바뀌지 않아야 불변 데이터라 할 수 있다. 최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이어야 한다. **중첩된 데이터의 일부를 바꾸려면 변경하려는 값과 상위의 모든 값을 복사해야 한다.**

### 중첩된 쓰기를 읽기로 바꾸기

```javascript
function setPriceByName(cart, name, price) {
  for (let i = 0; i < cart.length; i++) {
    if (cart[i].name === name) {
      cart[i].price = price;
    }
  }
}
```

이 코드는 제품 이름으로 해당 제품의 가격을 바꾸는 쓰기 동작이다. 이 동작은 중첩된 데이터 구조를 바꿔야 하는 조금 특별한 동작이다. 장바구니 배열 안에 **중첩된 항목을 바꿔야 한다.**

중첩된 항목을 바꿔야 할 때는 가장 안쪽에 있는 쓰기 동작부터 바꾸는 것이 쉽다.

```javascript
function setPriceByName(cart, name, price) {
  let cartCopy = cart.slice(); // 카피-온-라이트
  for (let i = 0; i < cartCopy.length; i++) {
    if (cartCopy[i].name === name) {
      cartCopy[i] = setPrice(cartCopy[i], price); // 중첩된 항목을 바꾸는 카피-온-라이트 동작
    }
  }
  return cartCopy;
}

// objectSet() 함수를 사용해 물건에 새로운 값을 설정하는 함수
function setPrice(item, new_price) {
  return objectSet(item, "price", new_price);
}

// 카피-온-라이트 방식으로 객체에 값을 설정하는 함수
function objectSet(object, key, value) {
  let copy = Object.assign({}, object);
  copy[key] = value;
  return copy;
}
```

- 카피-온-라이트란?
  - 데이터를 불변형으로 유지할 수 있는 원칙이다.
  - 복사본을 만들고 원본 대신 복사본을 변경하는 것을 말한다.

---

> 함수형 코딩은 함수를 엄청 쪼개서 아주 작은 단위로 나누고, 믿을 수 있는 함수를 조합해 나간다.
