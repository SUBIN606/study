# 15장 이진 탐색 트리로 속도 향상

정렬된 배열은 순서대로 데이터를 유지하는 간단하면서도 효과적인 도구다. 또한 특정 연산에 매우 빨라서 읽기에는 O(1), 검색(이진 검색)에는 O(logN)이 걸린다.

하지만 삽입과 삭제가 상대적으로 느리다. 정렬된 배열에 값을 삽입할 때마다 먼저 더 큰 값을 전부 한 셀 오른쪽으로 시프트해야 한다. 또한, 정렬된 배열에서 값을 삭제할 때마다 더 큰 값을 전부 한 셀 왼쪽으로 시프트해야 한다. 최악의 시나리오의 경우 N단계가 걸리고, 평균적으로 N / 2단계가 걸린다. 어쨌든 O(N)이고, O(N)은 단순한 삽입이나 삭제치고 비교적 느리다.

## 15.1 트리

트리(tree)역시 노드 기반 자료 구조이지만 트리의 각 노드는 **여러 노드로의 링크를 포함**할 수 있다.

## 15.2 이진 탐색 트리

이진 탐색 트리는 트리에 이진(binary)과 탐색(search)이라는 수식어 두 개가 붙는다.

### 이진 탐색 트리 규칙

- 각 노드의 자식은 최대 왼쪽에 하나, 오른쪽에 하나다.
- 한 노드의 왼쪽 자손은 그 노드보다 작은 값만 포함할 수 있고, 오른쪽 자손은 그 노드보다 큰 값만 포함할 수 있다.

이진 탐색 트리로서 유효하려면 최대 왼쪽 자식 하나, 오른쪽 자식 하나만 있어야 한다.

```python
class TreeNode:
    def __init__(self, val, left=None, right=None):
      self.value = val
      self.leftChild = left
      self.rightChild = right
```

```python
node1 = TreeNode(25)
node2 = TreeNode(75)
root = TreeNode(50, node1, node2)
```

## 15.3 검색

### 이진 탐색 트리를 검색하는 알고리즘

1. 노드를 현재 노드로 지정한다 (알고리즘을 시작할 때는 루트 노드가 첫 번째 현재 노드다)
2. 현재 노드의 값을 확인한다
3. 찾고 있는 값이면 좋다
4. 찾고 있는 값이 현재 노드보다 작으면 왼쪽 하위 트리를 검색한다.
5. 찾고 있는 값이 현재보다 크면 오른쪽 하위 트리를 검색한다.
6. 찾고 있는 값을 찾았거나 트리 바닥에 닿을 때까지(찾고 있는 값이 트리에 없는 경우) 1단계부터 5단계를 반복한다.

### 이진 탐색 트리 검색의 효율성

이진 탐색 트리 검색은 각 단계마다 남은 값 중 반을 제거하는 알고리즘을 나타내는 O(logN)이다.

## 15.4 삽입

**이진 탐색 트리는 삽입에 가장 뛰어나다.**

삽입은 항상 검섹에 한 단계 더 추가된다. 즉, (logN) + 1단계가 걸리며 빅 오는 상수를 무시하므로 O(logN)이다.

정렬된 배열에서는 검색뿐 아니라 값을 삽입할 공간을 마련하기 위해 많은 데이터를 오른쪽으로 시프트해야 하기 때문에 삽입에 O(N)이 걸린다.

무작위로 정렬된 데이터로 트리를 생성해야 대개 균형이 잡힌 트리가 생성된다. 정렬된 데이터를 트리에 삽입하면 불균형이 심하고 덜 효율적일 수 있다. 이러한 이유로 정렬된 배열을 이진 탐색 트리로 변환하고 싶을 때는 먼저 데이터 순서를 무작위로 만드는 게 좋다.

## 15.5 삭제

삭제는 이진 탐색 트리에서 가장 어려운 연산이며 주의 깊게 실행해야 한다.

- 삭제할 노드에 자식이 없으면 그냥 삭제한다.
- 삭제할 노드에 자식이 하나면 노드를 삭제하고, 그 자식을 삭제된 노드가 있던 위치에 넣는다.
- 자식이 둘인 노드를 삭제할 때는 삭제된 노드를 후속자(successor)노드로 대체한다.

> 후속자 노드란 삭제된 노드보다 큰 값 중 최솟값을 같는 자식 노드다. (방금 삭제한 노드의 자식 노드들을 오름차순 정렬했을 때 방금 삭제한 노드 다음으로 큰 수)

### 후속자 노드 찾기

삭제된 값의 오른쪽 자식을 방문해서 그 자식의 왼쪽 자식을 따라 계속해서 방문하며 더 이상 왼쪽 자식이 없을 때 까지 내려간다. 바닥 값이 후속자 노드다.

만약 후속자 노드에 오른쪽 자식이 있으면 후속자 노드를 삭제된 노드가 있던 자리에 넣은 후, 후속자 노드의 오른쪽 자식을 후속자 노드의 원래 부모의 왼쪽 자식으로 넣는다.

### 완전한 삭제 알고리즘

1. 삭제할 노드에 자식이 없으면 그냥 삭제한다.
2. 삭제할 노드에 자식이 하나면 노드를 삭제하고 자식을 삭제된 노드가 있던 위치에 넣는다.
3. 자식이 둘인 노드를 삭제할 때는 삭제된 노드를 후속자 노드로 대체한다.
4. 후속자 노드를 찾기 위해 삭제된 값의 오른쪽 자식을 방문해 그 자식의 왼쪽 자식을 따라 더 이상 왼쪽 자식이 없을 때 까지 내려간다. 바닥 값이 후속자 노드다.
5. 만약 후속자 노드에 오른쪽 자식이 있으면 후속자 노드를 삭제된 노드가 있던 자리에 넣은 후, 후속자 노드의 오른쪽 자식을 후속자 노드의 원래 부모의 왼쪽 자식으로 넣는다.
   > 후속자 노드는 삭제하려는 값보다 큰 값 중 작은 값이 된다!

## 15.6 이진 탐색 트리 다뤄보기

이진 탐색 트리는 검색과 삽입, 삭제에서 O(logN)의 효율성을 갖는다.

정렬된 배열은 데이터 검색이 이진 탐색 트리만큼 빠르지만 **이진 탐색 트리는 데이터 삽입과 삭제가 훨씬 빠르므로 데이터를 자주 수정할 경우 특히 효율적**이다.

## 15.7 이진 탐색 트리 순회

자료 구조에서 모든 노드를 방문하는 과정을 자료 구조 순회(traversal)이라 부른다.

> 순서대로 뽑고싶으면 중위 순회 한다.

---

전위 순회와 후위 순회

---

<details>
<summary>트리의 특징이 무엇인가?</summary>
<p>연결 리스트와 마찬가지로 노드 기반 자료 구조이지만, 트리의 각 노드는 여러 노드로의 링크를 포함할 수 있다.</p>
</details>

<details>
<summary>이진 탐색 트리의 규칙은 무엇인가?</summary>
<p>왼쪽에는 본인 노드보다 작은 자식 노드를, 오른쪽에는 본인 노드보다 큰 자식 노드를 가져야 한다.</p>
</details>

<details>
<summary>이진 탐색 트리의 검색하는 과정?</summary>
<p>루트 노드부터 시작한다. 노드의 값이 찾으려는 값보다 작으면 왼쪽 하위 트리를, 크면 오른쪽 하위트리를 검색해 나간다. 찾는 값이 없거나 트리 바닥까지 도달한 경우 다시 반복한다.</p>
</details>

<details>
<summary>이진 탐색 트리의 삽입하는 과정?</summary>
<p>삽입은 검색해서 삽입할 자리를 찾은 후 삽입한다.</p>
</details>

<details>
<summary>자식이 하나인 노드를 삭제하는 과정에 대해 말해보라</summary>
<p>자식이 하나인 경우에는 삭제할 노드를 삭제한 뒤에 자식 노드를 삭제한 위치에 넣는다.</p>
</details>

<details>
<summary>후속자 노드란 무엇이며, 후속자 노드를 찾는 과정에 대해 말해보라</summary>
<p>후속자 노드란 자식이 둘인 노드를 삭제할 때, 삭제할 노드의 자리를 대체하게 될 노드다.</p>
<p>후속자 노드를 찾는 방법은 우선 삭제된 노드의 오른쪽 자식을 방문해서 그 자식의 왼쪽 노드를 따라 바닥까지 내려가서 만난 노드가 후속자 노드가 된다. 만약 후속자 노드에 오른쪽 자식이 있는 경우에는 후속자 노드 자리를 오른쪽 자식이 채운다.</p>
</details>

<details>
<summary>정렬된 배열과 이진 탐색 트리의 차이점?</summary>
<p>이진 탐색 트리가 정렬된 배열보다 삽입과 삭제가 빠르다. 그래서 데이터를 자주 수정하는 경우 이진 탐색 트리가 특히 효율적이다.</p>
</details>
