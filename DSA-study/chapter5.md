### 5.1 선택 정렬

- 선택 정렬의 과정?

  1. 배열의 맨 왼쪽 부터 오른쪽까지 돌면서 최소값의 위치를 알아낸다.
  2. 배열의 맨 왼쪽(패스 스루를 시작한 위치)과 최소값을 교환한다.
  3. 배열 끝에서부터 시작하는 패스 스루에 도달할 때 까지 반복한다.

### 5.2 선택 정렬 실제로 해보기

- 선택 정렬을 코드로 구현해보라
  ```java
  int[] selectionSort(int[] arr) {

  	for(int i = 0; i < arr.length - 1; i++) {
  		int minNumIndex = i;

  		for(int j = i + 1; j < arr.length; j++) {
  				if(arr[j] < arr[minNumIndex]) {
  						minNumIndex = j;
  				}
  		}

  		if(i != minNumIndex) {
  			int temp = arr[i];
  			arr[i] = arr[minNumIndex];
  			arr[minNumIndex] = temp;
  		}
  	}

  	return arr;
  }
  ```

### 5.3 선택 정렬의 효율성

- 배열이 내림차순으로 정렬된 경우 버블 정렬과 선택 정렬의 단계 수를 비교하시오

  배열이 내림차순으로 정렬된 경우는 최악의 시나리오다. 두 정렬 모두 패스스루를 원소의 개수만큼 실행하고, 매번 비교하지만 버블정렬은 이 시나리오에서 패스스루의 원소 개수만큼 또 교환 단계를 거쳐야 한다. 하지만 선택 정렬은 한 패스스루에서 최대 한 번의 교환만 일어나게 된다.

  선택 정렬이 버블 정렬보다 약 두 배 정도 빠르다.

### 5.4 상수 무시하기

- N단계를 거치는 알고리즘과 100N의 단계를 거치는 알고리즘의 빅 오 표기법은 어떻게 되나?

  둘 다 똑같이 O(N)이다. 빅 오 표기법은 지수가 아닌 수는 포함하지 않기 때문이다.

### 5.5 빅 오 카테고리

- 빅 오에서 중요한 것은…

  빅 오 표기법은 단지 알고리즘에 필요한 단계 수만 의미하지 않는다. 데이터가 늘어날 때 알고리즘 단계 수가 장기적으로 어떤 궤적을 그리는지가 중요하다.

- O(N)과 O(N²)의 궤적을 비교해봐라

  직선 성장

  지수 성장

  어쨌든 결국은 O(N²)가 느려진다.

- 두 가지의 알고리즘이 같은 카테고리에 속한다는 것은 처리속도가 동일하다는 것을 뜻하는가

  다르다!

  버블정렬과 선택정렬은 모두 동일하게 O(N²)이지만, 선택 정렬이 버블 정렬보다 약 2배 빠르다.
