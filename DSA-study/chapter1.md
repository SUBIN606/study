# 1장 자료 구조가 중요한 까닭

코드 품질은 다양한 척도로 평가할 수 있다. 한 가지 중요한 척도가 **코드 유지 보수성**이다. 코드 유지 보수성은 가독성, 조직, 코드 모듈성 같은 측면을 포함한다.
고품질 코드에는 또 다른 측면이 있는데 바로 **코드 효율성**이다.

> 같은 목적을 달성하는 두 코드가 있을 때, 더 빠르게 실행되는 코드가 더 효율성이 높은 코드라고 한다.

## 1.1 자료구조

자료구조란 데이터를 조직하는 방법이다.

데이터를 어떻게 조직하는가에 따라 프로그램은 수십 수백 배 더 빠르게 혹은 더 느리게 실행될 수 있다.

## 1.2 배열: 기초 자료 구조

배열은 단순한 데이터 원소들의 리스트다.

## 1.3 속도 측정

연산이 얼마나 "빠른가"를 측정할 때는 순수하게 시간 관점에서 연산이 얼마나 빠른가가 아니라 **얼마나 많은 단계가 필요한지**를 논해야 한다.

연산을 실행하는 하드웨어에 따라 시간은 항상 바뀌기 때문에 시간을 기준으로 속도를 측정하면 신뢰할 수 없다.

대신 연산의 속도를 측정할 때 **얼마나 많은 계산 단계(step)가 필요한가를 따져봐야 한다**.

## 1.4 읽기

읽기는 배열 내 특정 인덱스에 어떤 값이 들어있는지 찾아보는 것이다.

컴퓨터가 배열의 특정 인덱스에 있는 값을 읽을 때 한 번의 단계(`O(1)`)로 바로 갈 수 있다.
컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있고, 배열을 할당할 때 어떤 메모리 주소에서 시작하는지도 기록해 두기 떄문이다.

## 1.5 검색

검색은 배열에 특정 값이 있는지 알아본 후, 있다면 어떤 인덱스에 있는지 찾는 것이다.

컴퓨터는 모든 메모리 주소에 한 번에 접근하지만 각 메모리 주소에 어떤 값이 있는지 바로 알지 못한다.

> 값으로 위치를 찾는 검색은 위치로 값을 찾는 읽기와 반대다.

검색은 배열의 맨 앞(0번째 index)부터 차례대로 값을 비교해 찾는다. 만약 크기가 5인 배열에서 찾는 값이 맨 마지막에 위치해 있다면 최대 5단계를 거친다.

즉, 검색은 N개의 셀로 이루어진 배열에서 최대 N개의 단계가 필요하다고 말할 수 있다.

## 1.6 삽입

배열에 새 데이터를 삽입하는 연산은 배열의 어디에 데이터를 삽입하는가에 따라 효율성이 다르다.

배열의 맨 마지막에 추가할 때는 새 값을 삽입할 메모리 주소를 계산할 수 있고, 한 단계(`O(1)`)면 된다.

하지만 배열의 맨 앞이나 중간에 삽입해야 할 경우에는 삽입할 공간을 만들기 위해 많은 데이터 조각을 이동시켜야 하므로 단계가 늘어난다.

최악의 시나리오는 배열의 맨 앞에 삽입하는 경우인데, 이 때 모든 원소들을 오른쪽으로 옮긴 후 맨 앞에 삽입해야 하므로 최악의 경우 `N+1`단계가 걸린다.

## 1.7 삭제

배열의 삭제는 특정 인덱스의 값을 제거하는 과정이다.

삭제 자체는 1단계 걸리지만(인덱스로 접근해 바로 삭제할 수 있으니까) 중간에 빈 공간이 생기면 데이터를 옮겨야 한다. 즉, 삭제 과정은 1단계보다 더 필요하다.

최악의 시나리오는 삽입과 같이 맨 앞의 데이터를 삭제하는 경우다. 맨 앞에 빈 공간이 생기게 되므로 오른쪽에 있는 모든 데이터들을 왼쪽으로 옮겨야 한다.
크기가 5인 배열의 맨 앞 원소를 삭제하는 데 1단계, 그리고 나머지 네 개의 원소를 왼쪽으로 옮기는 데 4단계가 걸린다. 즉 `N`단계가 걸린다.

## 1.8 집합: 단 하나의 규칙으로 효율성이 달라진다

집합은 중복 값을 허용하지 않는 자료 구조다.

**배열 기반 집합**은 값들의 단순 리스트로 배열과 거의 비슷하지만, 중복 값의 삽입을 절대 허용하지 않기 때문에 중복 데이터가 없어야 할 때 유용하다.

**배열 기반 집합은 중복 금지라는 제약이 하나 더 추가된 배열**이다. 이 간단한 제약으로 인해 주요 연산 중 삽입에서 집합의 효율성이 크게 달라진다.

배열과는 다르게 배열 기반 집합은 삽입하기 전에 검색 단계가 필수로 요구된다. 중복을 허용하지 않기 때문에 삽입 전에 지금 삽입하려는 값을 이미 가지고 있는지 확인해야 하기 때문이다.

집합의 끝에 삽입하려면 원소 N개에 대해 최대 `N+1`단계가 필요하고, 맨 앞에 삽입하는 최악의 시나리오일 때 총 `2N+1`의 단계가 필요하다.

---

<details>
<summary>책에서 말하는 자료 구조가 중요한 이유?</summary>
<p>
효율적인 코드를 작성하기 위해서다. 효율적인 코드란 같은 목적을 달성하는 코드가 여러 개 일 때 더 빠르게 실행되는 코드를 효율적인 코드라고 말한다.</p>
<p>
효율적인 코드를 작성하려면 자료구조가 무엇인지, 다양한 자료 구조가 코드 속도에 어떠한 영향을 미치는지 이해해야 한다.
자료구조에 따라 프로그램은 더 빠르게, 혹은 더 느리게 실행될 수 있다.
</p>
</details>
<details>
<summary>연산이 얼마나 빠른가를 측정할 때 삼아야 하는 기준이 무엇인가?</summary>
<p>
연산에 걸리는 계산 단계를 따져봐야 한다. 
</p>
<p>
연산을 실행하는 하드웨어의 성능이 각각 다르므로 절대적인 '시간'을 기준으로 삼으면 하드웨어마다 다를 수 밖에 없다. 이런 결과는 신뢰할 수 없다. 반면 연산에 걸리는 계산 단계는 동일하기 때문에 계산 단계가 얼마나 필요한지를 따져봐야 한다.
</p>
</details>
<details>
<summary>배열의 읽기, 검색, 삽입, 삭제에 걸리는 단계 수는 얼마이며 왜 그런 단계를 거치게 되는지 설명하라.</summary>
<p>
배열의 읽기는 한 단계가 걸린다. 컴퓨터는 메모리 주소에 바로 접근할 수 있기 때문인데, 배열을 저장할 때 컴퓨터는 배열의 첫 번째 메모리 주소를 기록해둔다.
만약 크기가 10인 배열에서 세 번째 원소에 접근한다고 할 때 첫 번째 메모리 주소에 2를 더해서 메모리 주소를 알 수 있고, 메모리 주소를 알면 컴퓨터는 바로 접근할 수 있다.
</p>
<p>
검색은 최악의 경우 원소의 개수만큼의 단계가 걸린다. 컴퓨터는 메모리 주소로 바로 접근할 수 있지만 그 안의 값은 알지 못하기 떄문에 맨 앞의 원소부터 차례대로 값을 비교해야 한다.
만약 검색하는 값이 배열의 맨 마지막에 위치하고 있다면 맨 마지막 까지 검색하는 단계가 걸리므로 N단계가 걸린다.
</p>
<p>
삽입은 최선의 경우 1단계, 최악의 경우 N+1단계가 걸린다. 최선의 경우는 배열의 맨 마지막에 삽입할 경우로 간단하게 맨 마지막에 값을 추가하기만 하면 된다.
하지만 배열의 맨 앞 혹은 중간에 삽입하는 경우에는 단계가 추가된다. 삽입하려는 위치에 빈 공간을 만들어야 하기 때문이다. 최악의 경우는 배열의 맨 앞에 추가하는 경우로 원소의 개수만큼 오른쪽으로 원소들을 옮기는 과정인 N단계가 필요하고, 빈 자리에 원소를 삽입하는 1단계가 추가되어 N+1단계가 걸린다.
</p>
<p>
삭제는 인덱스로 인덱스에 위치한 값을 삭제하는 과정이다. 인덱스를 알면 바로 접근할 수 있으므로 삭제 자체는 1단계가 걸린다. 하지만 배열의 맨 앞이나 중간에 값을 삭제하게 되면 단계가 추가된다. 빈 공간이 생기기 때문인데, 배열 내의 빈 공간을 메꾸기 위해 원소를 이동시켜야 한다.
최악의 경우 N단계가 걸린다. 배열의 맨 앞의 원소를 삭제할 경우 맨 앞에 원소를 삭제하는 1단계에 뒤의 N-1개의 원소들을 모두 왼쪽으로 옮겨 빈 공간을 없애는 과정이 추가된다. 즉 N단계가 소요된다.
</p>
</details>
