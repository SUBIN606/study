# 16. 힙으로 우선순위 유지하기

힙은 데이터 세트에서 가장 크거나 작은 데이터 원소를 계속 알아내야 할 때 특히 유용하다.

## 16.1 우선순위 큐

- 우선순위 큐에 대해 설명해 보세요.
  - 우선순위 큐는 데이터 접근과 삭제는 앞에서 하지만, 삽입할 때는 데이터를 특정 순서대로 정렬한다.
- 큐와 우선순위 큐의 차이점에 대해 설명해보세요.
  - 큐와 우선순위 큐 모두 접근과 삭제를 맨 앞에서부터 한다. 삽입에서 차이가 있는데, 큐는 뒤로 추가하고 우선순위 큐는 삽입할 때 우선순위에 따라 정렬하는 과정이 추가된다.

## 16.2 힙

- 이진 힙이란 무엇인가?
  - 특수한 종류의 이진 트리로, **각 노드의 값은 그 노드의 모든 자손의 값보다 커야하며 트리는 완전해야 한다는 조건(힙 조건)** 을 가지고 있다.
  - 완전 트리란 빠진 노드 없이 노드가 완전히 채워진 트리다. 바닥 줄에는 빈 자리가 있을 수 있지만 빈 자리의 오른쪽으로 어떤 노드도 없어야 한다.
- 이진 탐색 트리로 힙을 만들 수 있는가? 없다면 그 이유는 무엇인가?
  - 만들 수 없다. 이진 탐색 트리는 노드의 값보다 작으면 왼쪽 자손으로, 크면 오른쪽 자손으로 연결한다. 하지만 힙은 노드는 그 노드의 모든 자손보다 커야 한다는 힙 조건을 지켜야 하기 때문에 이진 탐색 트리로는 만들 수 없다.

## 16.3 힙 속성

- 힙을 이진 탐색 트리에 비해 약한 정렬(weakly ordered)이라고 말하는 이유는 무엇인가?
  - 힙에는 자손이 조상보다 클 수 없다는(혹은 작을 수 없다는) 분명한 순서가 존재하지만 값을 검색하기엔 부족하다. 이진 탐색 트리는 노드의 값보다 작으면 왼쪽 자손, 크면 오른쪽 자손이라는 규칙이 있어서 검색하기에 분명한 기준이 있다.
- 힙의 주요 연산은 무엇인가?
  - 힙의 주요 연산은 삽입과 삭제다. 검색은 모든 노드를 검사해야 하므로 대개 검색 연산을 구현하지 않는다.
- 힙의 마지막 노드는 무엇인가?
  - 트리의 바닥 레벨에서 가장 오른쪽에 있는 노드를 마지막 노드라고 한다.

## 16.4 힙 삽입

- 힙에 새 값을 삽입하는 과정에 대해 설명해보라
  - 먼저 **새 값을 힙의 마지막 노드 옆에 삽입해 새 값을 마지막 노드로 만든다.** 그리고 새로 삽입한 노드와 부모 노드를 비교해서 **새 노드가 부모 노드보다 크면 부모 노드와 스왑한다.** 새 노드보다 큰 부모 노드를 만날 때까지 스왑을 반복하여 새 노드를 힙 위로 올린다. **스왑을 반복해서 새 노드를 위로 올리는 과정을 트리클링이라고 한다.**
- 트리클링이란?
  - 힙이 약한 정렬을 유지할 수 있도록 새로운 노드의
- 힙 삽입의 효율성은 무엇인가?
  - 힙 삽입의 효율성은 O(logN)이다. 노드가 N개인 이진 트리가 약 log(N)개의 레벨을 갖고, 최악의 경우 삽입하려는 값을 맨 윗줄 까지 올려야 하기 때문이다.

## 16.5 마지막 노드 탐색

## 16.6 힙 삭제

- 힙의 삭제 과정에 대해 말해보라
  - 우선 힙은 무조건 루트 노드만 삭제할 수 있다. 그래서 마지막 노드를 루트 노드로 옮겨 원래 루트 노드를 삭제한 뒤 루트 노드를 적절한 자리 까지 아래로 트리클링 한다.
  - **아래로 트리클링 하는 법은 노드의 두 자식 중 큰 노드보다 노드가 작으면 큰 자식 노드와 노드를 스왑한다.** 노드보다 큰 자식이 없을 때까지 반복한다. 그리고 삽입과 마찬가지로 최악의 경우 노드를 맨 아래 레벨까지 내려야 하기 때문에 O(logN)의 시간 복잡도가 나온다.

## 16.7 힙 대 정렬된 배열

- 힙은 정렬된 배열보다 어떤 점이 우수하며 언제 사용하는 것이 좋은가?
  - 정렬된 배열의 삽입은 O(N), 삭제는 O(1)의 시간복잡도를 가지고, 힙은 삽입과 삭제 모두 O(logN)의 시간복잡도를 갖는다. 졍렬된 배열의 삭제가 매우 빠르긴 하지만 O(logN)도 빠르고, O(N)보다도 빠르다. **힙은 삽입과 삭제 모두 빠르기 때문에 우선순위를 유지하면서 빠른 삽입과 삭제가 필요한 경우 사용하면 좋다.**

## 16.8 다시 살펴보는 마지막 노드 문제

- 힙의 삽입과 삭제에서 마지막 노드를 찾는 이유는 무엇인가?
  - 균형잡힌 힙으로 유지하기 위해서다. 마지막 노드를 찾아 삽입하거나 삭제하지 않으면 힙의 균형이 깨지게 되고, 힙의 균형이 깨진면 O(logN)안에 연산이 불가능해진다.

## 16.9 배열로 힙 구현하기

- 힙을 배열로 구현하는 이유는 무엇인가?
  - 배열로 힙을 구현하면 배열의 첫 번째 원소는 힙의 루트 노드가 되고, 마지막 원소는 마지막 노드가 된다. 아주 쉽게 루트 노드와 마지막 노드를 찾을 수 있다.
- 노드와 연결된 자식 노드를 찾는 공식은 무엇인가?
  - 어떤 노드의 왼쪽 자식을 찾으려면 `(index * 2) + 1` 공식을 사용한다.
  - 어떤 노드의 오른쪽 자식을 찾으려면 `(index * 2) + 2` 공식을 사용한다.
  - 어떤 노드의 부모를 찾으려면 `(index - 1) / 2` 공식을 사용한다. (소숫점 이하는 버린다.)

---

# 우선순위 큐 관련 문제 풀어보기

스터디 내용 복습을 위해 우선순위 큐와 관련된 문제를 풀어보기로 한다.

## 문제

- [이중우선순위 큐](https://school.programmers.co.kr/learn/courses/30/lessons/42628)

### 문제 파악

이중 우선순위 큐는 숫자를 삽입하고, 최댓값 혹은 최솟값을 삭제하는 연산을 할 수 있는 자료구조다. 연산이 담긴 `operations`매개변수가 주어지고, 모든 연산을 처리한 후 큐가 비어있으면 `[0, 0]`을, 비어있지 않으면 `[최댓값, 최솟값]`을 반환하라.

### 제한사항

- `I`로 시작하는 연산은 큐에 값을 삽입한다.
- `D`로 시작하는 연산은 값을 삭제한다.
  - `D 1`은 최댓값을 삭제한다.
  - `D -1`은 최솟값을 삭제한다.
- 빈 큐에 데이터를 삭제하라는 연산이 주어지면 무시한다.

## 계획

우선 순위 큐는 힙 또는 정렬된 배열로 구현할 수 있다. 최댓값과 최솟값을 알려면 정렬된 배열을 사용하는 것이 좋겠다. 정렬된 배열의 첫 번째 값은 최솟값이 되고, 마지막 값은 최댓값이 된다.

1. `operations`배열을 반복문으로 돌면서 맨 앞 글자를 통해 어떤 연산인지 구분한다.
2. 삽입 연산의 경우 그냥 삽입한다.
3. 삭제 연산의 경우, 삭제 전 배열을 정렬한다.
   3-1. 최솟값을 삭제하는 경우 배열의 첫 번째 값을 삭제한다.
   3-2. 최댓값을 삭제하는 경우 배열의 마지막 값을 삭제한다.
4. 배열이 비어있으면 `[0, 0]`을, 비어있지 않으면 `[배열의 마지막 값, 배열의 첫 번째 값]`을 반환한다.

## 실행

```java
public int[] solution(String[] operations) {
    List<Integer> list = new ArrayList<>();
    int[] arr = new int[2];
    int[] answer = {};

    for (String command : operations) {
        if ('I' == command.charAt(0)) {
            int insertValue = Integer.parseInt(command.substring(2));
            list.add(insertValue);
        } else {
            list.sort(Integer::compareTo);
            int deleteCommand = Integer.parseInt(command.substring(2));

            if (list.isEmpty()) {
                continue;
            }
            if (deleteCommand > 0) {
                list.remove(list.get(list.size() - 1));
            } else {
                list.remove(list.get(0));
            }
        }
    }
    list.sort(Integer::compareTo);
    return list.isEmpty() ? new int[]{0, 0} : new int[]{list.get(list.size() - 1), list.get(0)};
}
```
