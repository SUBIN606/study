# 13장 속도를 높이는 재귀 알고리즘

컴퓨터 언어 중 대다수가 내부적으로 채택한 정렬 알고리즘이 바로 **퀵 정렬**이다.

## 13.1 분할

배열을 분할한다는 것은 배열로부터 임의의 수(피벗)를 가져와 피벗보다 작은 모든 수는 피벗의 왼쪽에, 피벗보다 큰 모든 수는 피벗의 오른쪽에 두는 것이다.

```java
// 배열을 분할 한다.
// 임의의 수 pivot을 설정하고, pivot 보다 작은 수는 왼쪽에, 큰 수는 오른쪽에 둔다.

// [조건]
// 1. LP는 pivot보다 큰 수를 만날 때 까지 오른쪽으로 옮긴다.
// 2. RP는 pivot보다 작은 수를 만날 때 까지 왼쪽으로 옮긴다.
// 3. 만약 LP가 RP를 만났거나 넘어선 경우라면 LP와 pivot을 교환한다.
// 4. 아니라면 LP와 RP를 교환하고 다시 진행한다.
private int partitioning(int[] arr, int left, int right) {
    int pivot = right;
    int pivotValue = arr[pivot];

    // 두 포인터를 사용해 배열 가장 왼쪽 값과 피벗 제외 가장 오른쪽 값을 할당한다.
    int leftPointer = left, rightPointer = pivot - 1;

    while (true) {
        // 왼쪽 포인터를 한 셀씩 오른쪽으로 옮기면서 피벗보다 크거나 같은 값에 도달하면 멈춘다.
        while (arr[leftPointer] < pivotValue) {
            leftPointer++;
        }

        // 오른쪽 포인터를 한 셀씩 왼쪽으로 옮기면서 피벗보다 작거나 같은 값에 도달하거나, 배열 맨 앞에 도달하면 멈춘다.
        while (arr[rightPointer] > pivotValue) {
            rightPointer--;
            if (0 >= rightPointer) {
                break;
            }
        }

        if (leftPointer >= rightPointer) {
            break;
        }

        if (leftPointer < rightPointer) {
            int temp = arr[leftPointer];
            arr[leftPointer] = arr[rightPointer];
            arr[rightPointer] = temp;

            leftPointer++;
        }

    }

    // 왼쪽 포인터가 오른쪽 포인터에 도달하거나 넘어섰으면 왼쪽 포인터 값과 피벗을 교환한다.
    arr[pivot] = arr[leftPointer];
    arr[leftPointer] = pivotValue;

    return leftPointer;
}
```

## 13.2 퀵 정렬

퀵 정렬 알고리즘은 분할과 재귀로 이뤄진다.

```java
void quickSort(int[] arr, int left, int right) {
    if (left >= right) {
        return;
    }

    int pivot = partitioning(arr, left, right);

    sort(arr, left, pivot - 1);
    sort(arr, pivot + 1, right);
}
```

## 13.3 퀵 정렬의 효율성

분할에 필요한 단계는 비교와 교환 두 가지다. 각 분할마다 배열 내 각 원소를 피벗과 비교하므로 최소 N번 비교한다.

교환 횟수는 데이터가 어떻게 정렬되어 있느냐에 따라 다르다. 가능한 값을 모두 교환한다 해도 한 번에 값 두개를 교환하므로 한 분할에서 최대 N / 2번 교환한다.

따라서 N번 비교하고, N / 2번 교환한다. 빅 오 표기법은 상수를 무시하므로 `O(N)` 시간에 분할을 실행한다고 볼 수 있다.

퀵 정렬은 기본적으로 연이은 분할로 수행되는데, 각 분할마다 하위 배열의 원소가 N개 일때 약 N단계가 걸린다. 결국 **모든 하위 배열의 크기를 합하면 퀵 정렬에 걸리는 총 단계 수**가 나온다.

크기가 1이 될 때까지 각 하위 배열을 반으로 나누려면 `logN`번 걸린다. 따라서 퀵 정렬에는 `N * logN`단계가 걸린다. logN번 반으로 나누고, 나눌 때마다 모든 하위 배열에 대해 분할을 수행하는데 그 하위 배열의 원소 수를 모두 합하면 N이다.

## 13.4 퀵 정렬의 최악의 시나리오

퀵 정렬의 최선의 시나리오는 분할 후 피벗이 하위 배열의 한가운데 있을 때다.

퀵 정렬에서 최악의 시나리오는 피벗이 항상 하위 배열의 정중앙이 아닌 한쪽 끝에 있을 때다. 배열이 완전히 오름차순 또는 내림차순일 때 일어날 수 있다.

> 그래서 배열을 한 번 무작위로 섞은 다음 퀵 정렬을 하기도 한다.

퀵 정렬이 삽입 정렬보다 훨씬 우수한 까닭은 평균 시나리오 때문이다. 평균적인 상황에서 퀵 정렬이 우수하므로 내부적으로 퀵 정렬을 사용해 내장 정렬 함수를 구현하는 언어가 많다.

|   정렬    | 최선의 경우 | 평균적인 경우 | 최악의 경우 |
| :-------: | ----------- | ------------- | ----------- |
| 삽입 정렬 | O(N)        | O(N²)         | O(N²)       |
|  퀵 정렬  | O(NlogN)    | O(NlogN)      | O(N²)       |

## 13.5 퀵 셀렉트

퀵 셀렉트도 분할에 기반하며, 퀵 정렬과 이진 검색의 하이브리드 정도로 생각할 수 있다.

분할이 끝나면 피벗 값은 배열 내 올바른 위치에 있게 된다. 퀵셀렉트는 이 정보를 활용한다.

퀵 셀렉트의 훌륭한 점 중 하나는 전체 배열을 정렬하지 않고도 올바른 값을 찾을 수 있다는 것이다. 퀵 셀렉트는 배열을 반으로 나눌 때마다 필요한 반쪽, 즉 찾고 있는 값이 있을 반쪽만 분할하면 된다.

## 13.6 다른 알고리즘의 핵심 역할을 하는 정렬

현재까지 알려진 가장 빠른 정렬 알고리즘의 속도는 `O(NlogN)`이다. 퀵 정렬이 가장 유명하나 다른 알고리즘도 많다.

많은 알고리즘에서 정렬을 더 큰 프로세스의 일부로 사용한다. 그렇게 함으로서 최소 `O(NlogN)` 알고리즘이 된다는 사실을 이제 알았다.
