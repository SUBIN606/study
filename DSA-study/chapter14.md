# 14장 노드 기반 자료 구조

**노드(node)**란 컴퓨터 메모리 곳곳에 흩어져 있는 데이터 조각이다. 노드 기반 자료 구조는 데이터를 조직하고 접근하는 새로운 방법을 제공하는데 성능상 큰 이점이 많다.

## 14.1 연결 리스트

연결 리스트(linked list)는 배열과 마찬가지로 항목의 리스트를 표현하는 자료 구조다. 배열과 연결 리스트는 외견상 상당히 비슷한 모습으로 동작하지만 내부적으로는 크게 다르다.

연결 리스트 내 데이터는 연속된 메모리 블록이 아니라 컴퓨터 메모리 전체에 걸쳐 여러 셀에 퍼져 있을 수 있다.

메모리 곳곳에 흩어진 연결된 데이터를 노드라 부른다. 연결 리스트에서 각 노드는 리스트 내 한 항목을 나타낸다. 각 노드는 약간의 추가 정보, 즉 연결 리스트 내에 링크(link)라 부르는 **다음 노드의 메모리 주소**도 포함한다.

컴퓨터가 연결 리스트의 시작 메모리 주소를 알면 그 리스트를 다룰 준비가 끝난다. 컴퓨터는 각 링크를 따라 전체 리스트를 연결 하기만 하면 된다.

데이터가 컴퓨터 메모리 전체에 흩어질 수 있다는 점에서 연결 리스트가 배열보다 유리할 수 있다.

## 14.2 연결 리스트 구현

> TODO 연결 리스트 java로 구현하기

## 14.3 읽기

연결 리스트에서 읽기의 효율성은 최악의 경우 `O(N)`이다.

배열은 인덱스로 O(1)만에 값을 읽을 수 있지만, 연결 리스트는 먼저 첫 번째 노드에 접근하고 차례대로 다음 노드로 접근해야만 한다. 만약 읽으려는 값이 마지막에 있다면 첫 번째 노드 부터 마지막 노드까지 차례대로 따라가야 한다.

연결 리스트 읽기에서 최악의 시나리오가 `O(N)`이라는 점은 어떤 원소든 `O(1)`만에 읽는 배열에 비해 심각한 단점이다.

## 14.4 검색

연결 리스트의 검색 속도도 배열과 동일하게 `O(N)`이다.

## 14.5 삽입

연결 리스트가 배열에 비해 뚜렷한 장점을 보이는 연산이 삽입 연산이다.
연결 리스트는 리스트 맨 앞에 삽입하는 데 딱 한 단계, `O(1)`만 걸린다.

> 배열의 경우 맨 앞에 삽입할 경우 `O(N)`의 단계를 거친다.

연결리스트는 데이터를 하나도 시프트하지 않고 리스트 앞에 데이터를 삽입할 수 있는 유연성이 있다.

리스트 끝에 삽입하는 최악의 시나리오는 `N + 1`단계가 걸리기 때문에 사실상 연결 리스트 삽입은 `O(N)`이다. 하지만 리스트 앞에 삽입하는 최선의 시나리오에는 `O(1)`이다.

즉 배열은 끝에 삽입할 때, 연결 리스트는 앞에 삽입할 때 유리하다.

## 14.6 삭제

연결 리스트의 삭제는 삽입과 마찬가지로 리스트 앞에서 삭제할 때 가장 빠르다.
연결 리스트 앞에서 노드를 삭제하려면 한 단계면 된다. 연결 리스트의 첫 번째 노드가 두 번째 노드를 가리키게 하면 된다.

연결 리스트에서 마지막 노드를 삭제하는 경우, 실제 삭제에는 한 단계가 걸리지만 리스트 앞에서부터 시작해서 노드에 도착할 때 까지 링크를 따라가야 하므로 단계가 추가된다.

연결 리스트 앞이나 뒤에서의 삭제는 간단하지만 중간에서의 삭제는 조금 더 복잡하다. 먼저 삭제하려는 노드의 바로 앞 노드에 접근한 후 해당 노드의 링크가 삭제하려는 노드 바로 뒤 노드를 가리키도록 바꾼다.

연결 리스트에서 노드를 삭제해도 그 노드는 여전히 메모리 어딘가에 남는다. 리스트 내 다른 노드와의 연결 고리를 끊음으로써 리스트에서만 제거할 뿐이다. 메모리에는 그대로 존재하지만 어쨌든 리스트에서 노드를 삭제하는 효과를 낳는다.

> 프로그래밍 언어마다 삭제된 노드를 처리하는 방식이 다르다.

## 14.7 연결 리스트 연산의 효율성

| 연산 | 배열                    | 연결 리스트             |
| ---- | ----------------------- | ----------------------- |
| 읽기 | O(1)                    | O(N)                    |
| 검색 | O(N)                    | O(N)                    |
| 삽입 | O(N) (끝에서 하면 O(1)) | O(N) (앞에서 하면 O(1)) |
| 삭제 | O(N) (끝에서 하면 O(1)) | O(N) (앞에서 하면 O(1)) |

연결 리스트가 효과적으로 쓰이려면 실제 삽입과 삭제가 `O(1)`이라는 점을 활용해야 한다.

## 14.8 연결 리스트 다루기

연결 리스트가 빛을 발하는 경우는 한 리스트를 검사해서 많은 원소를 삭제할 때다. 연결 리스트는 삽입이나 삭제 시 다른 데이터를 시프트하지 않아도 되므로 **전체 리스트를 훑으며 삽입이나 삭제를 수행하기에 매우 알맞은 자료 구조**다.

## 14.9 이중 연결 리스트

이중 연결 리스트는 각 노드에 2개의 링크를 포함한다. 한 링크는 다음 노드를 가리키고, 다른 한 링크는 앞 노드를 가리킨다.

이중 연결 리스트는 항상 첫 노드와 마지막 노드를 모두 알고 있으므로 각각 한 단계, 즉 `O(1)`에 접근할 수 있다.

전형적인 연결 리스트는 리스트 앞으로만 이동할 수 있다. 이전 노드를 모르기 때문에 뒤로는 이동할 수 없는 것이다. 하지만 이중 연결 리스트는 리스트 앞과 뒤로 모두 이동할 수 있어 훨씬 유연하다.

## 14.10 이중 연결 리스트 기반 큐

이중 연결 리스트는 `O(1)`시간에 리스트 끝에 데이터를 삽입하고, `O(1)`시간에 리스트 앞에서 데이터를 삭제할 수 있으므로 큐를 위한 완벽한 내부 자료 구조다.

큐는 끝에서 삽입하고 앞에서 삭제하므로 내부 자료 구조로서 이중 연결 리스트가 완벽하다.

---

<details>
<summary>연결 리스트와 배열을 비교해 보라</summary>
<p>
배열과 연결 리스트 모두 항목의 리스트를 표현하는 자료 구조라는 공통점이 있다.
</p>
<p>
배열은 컴퓨터 메모리를 연속적으로 차지하는 반면 연결 리스트는 컴퓨터 메모리 전체에 걸쳐 퍼져 있을 수 있다. 이 흩어진 연결된 데이터를 노드라 부르고, 연결 리스트의 노드는 다음 노드의 메모리 주소인 링크를 포함하고 있다.
</p>
<p>데이터가 메모리 전체에 흩어져 저장할 수 있다는 점에서 배열보다 유리할 수 있다.</p>
</details>

<details>
<summary>연결 리스트를 사용하면 좋은 상황은 언제인가?</summary>
<p>전체 리스트를 훓으면서 많은 삽입과 삭제가 필요한 경우에 유리하다. 삭제를 해도 시프트를 하지 않아도 되기 때문이다.</p>
</details>

<details>
<summary>전형적인 연결 리스트와 이중 연결 리스트의 차이점은 무엇인가?</summary>
<p>전형적인 연결 리스트의 노드는 다음 노드의 메모리 주소만 알고 있기 때문에 한 방향으로만 이동한다. 이중 연결 리스트는 노드의 앞과 뒤 노드의 주소도 알고 있기 때문에 양방향으로 이동할 수 있다.</p>
</details>
